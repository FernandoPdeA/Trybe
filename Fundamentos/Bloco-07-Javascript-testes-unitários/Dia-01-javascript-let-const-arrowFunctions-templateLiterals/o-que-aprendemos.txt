O que vamos aprender
Neste bloco e no pr√≥ximo, voc√™ vai aprender sobre a mais nova vers√£o do JavaScript, conhecida como ES6, ECMAScript 6 ou ES2015.
Esses v√°rios nomes podem gerar alguma d√∫vida, mas na verdade todos fazem refer√™ncia √† mesma linguagem. JavaScript √© como n√≥s chamamos a linguagem, s√≥ que esse nome √© um trademark da Oracle. O nome oficial da linguagem √© ECMAScript, e ES √© apenas a abrevia√ß√£o (ECMAScript).
Essa nova vers√£o possui alguns objetivos:
Ser uma linguagem melhor para construir aplica√ß√µes complexas;
Resolver problemas antigos do JavaScript;
Facilitar o desenvolvimento de libraries.
Fant√°stico n√£o √© mesmo? E tem mais... nesse bloco voc√™ vai ter o primeiro contato com mais uma ferramenta que far√° parte da sua vida de pessoa desenvolvedora: testes. Voc√™ aprender√° sobre a import√¢ncia de testar suas aplica√ß√µes e desenvolver orientado a testes. Al√©m disso, voc√™ vai aprender a instalar e utilizar a biblioteca do Jest para criar seus testes.
J√° na aula de hoje, voc√™ vai aprender quatro features do ES6 que s√£o muito importantes para que seu c√≥digo fique limpo e bem escrito, al√©m de resolverem alguns problemas da linguagem.
let;
const;
arrow functions;
template literals;
operador tern√°rio





Voc√™ ser√° capaz de:
Utilizar corretamente let e const;
Simplificar seu c√≥digo com arrow functions;
Simplificar a constru√ß√£o de strings com template literals;
Criar express√µes condicionais simplificadas com ternary operator.




Por que isso √© importante?
O let e o const vieram como solu√ß√£o para um antigo problema do JavaScript de falta de defini√ß√£o de escopo de vari√°veis. Sabe quando voc√™ declara uma vari√°vel dentro de um bloco e depois a utiliza fora dele? Isso √© um vazamento de vari√°vel. Esse problema sempre trouxe grandes preju√≠zos, principalmente para aplica√ß√µes maiores. Saber utilizar o let e o const de maneira consistente ir√° te ajudar a ter um c√≥digo mais confi√°vel e previs√≠vel.
As arrow functions, al√©m de deixar o c√≥digo mais leg√≠vel, quando bem utilizadas, ainda resolvem outro problema antigo do famigerado var that = this. Vamos ver esse problema com mais detalhes na sess√£o de conte√∫dos.
Os template literals s√£o importantes pois ir√£o nos ajudar a construir strings mais bem escritas e concisas, ajudando na preven√ß√£o de erros.
Por √∫ltimo, mas n√£o menos importante, vem o operador tern√°rio, ou ternary operator, que permite criar express√µes condicionais com dois outputs poss√≠veis em apenas uma linha.




Conte√∫dos
At√© aqui, voc√™ j√° foi apresentado a algumas features do ES6, como let, const e talvez at√© mesmo j√° tenha usado arrow functions, template literals e operador tern√°rio. Agora, voc√™ vai aprender as motiva√ß√µes para se usar cada um desses recursos para escrever c√≥digos mais limpos, concisos e identificar a presen√ßa desses elementos ao revisar c√≥digos de outras pessoas.



Parte I - var, let e const
Voc√™ certamente j√° se deparou com tr√™s diferentes formas de se declarar vari√°veis em Javascript:
var userEmail = 'maria@email.com';
let userId = '78945-6';
const userLocation = 'Brasil';
Qual a diferen√ßa entre essas declara√ß√µes? Apesar de serem utilizadas para o mesmo prop√≥sito, √© importante entender essas diferen√ßas para saber quando usar o var, let e const na hora de declarar vari√°veis. Afinal, quando declaradas na raiz do arquivo as tr√™s formas est√£o corretas e funcionam da mesma forma.
Em primeiro lugar, vamos entender o que √© o escopo em que a vari√°vel √© declarada. Podemos pensar em escopo como sendo o 'local' em que uma vari√°vel √© vis√≠vel e pode ser referenciada. Como exemplo, observe a fun√ß√£o abaixo:
Copiar
function userInfo() {
  let userEmail = 'maria@email.com';

  // Toda express√£o dentro do escopo da fun√ß√£o userInfo tem acesso √† vari√°vel userEmail
  console.log(userEmail);
}
userInfo();
Tente rodar a fun√ß√£o userInfo no seu editor de c√≥digo. Nesse caso, a vari√°vel userEmail foi declarada dentro do escopo da fun√ß√£o userInfo. Agora experimente mover o console.log(userEmail) para fora da fun√ß√£o e a execute novamente. Voc√™ ver√° um erro dizendo que userEmail n√£o √© definida - a vari√°vel s√≥ √© reconhecida dentro do escopo da fun√ß√£o. O que aconteceria se troc√°ssemos o let por var e const? N√£o deixe de fazer esse teste! Voc√™ ver√° que nos tr√™s casos, n√£o temos acesso √† vari√°vel fora do escopo da fun√ß√£o userInfo. Como saber, ent√£o, qual express√£o utilizar para declarar vari√°veis?
Veja este v√≠deo que fala sobre onde utilizar var, let e const.

Vamos agora pensar em vari√°veis declaradas dentro do escopo de um bloco de c√≥digo - como o corpo de um if ou um for. Acompanhe o exemplo abaixo e n√£o deixe de test√°-lo no seu editor de c√≥digo:
Copiar
if (true) {
  // inicio do escopo do if
  var userAge = '20';
  console.log(userAge); // 20
  // fim do escopo do if
}
console.log(userAge); // 20
Nesse exemplo, temos acesso √† vari√°vel userAge dentro e fora do bloco de c√≥digo. Experimente trocar o var por let e const. Qual ser√° o resultado? Temos acesso √† vari√°vel declarada com o var dentro e fora do escopo do bloco. No entanto, n√£o temos acesso √† userAge fora do bloco de c√≥digo quando usamos let e const para declarar essa vari√°vel. Isso √© interessante quando queremos trabalhar com vari√°veis acess√≠veis apenas no contexto daquele bloco de c√≥digo. Por ter um escopo mais abrangente, em aplica√ß√µes mais complexas declarar vari√°veis com o var pode confundir at√© mesmo programadores mais experientes.
Agora observe de uma forma um pouco mais visual como funcionam os escopos e o comportamento do var em casos que sua utiliza√ß√£o "vaza" o escopo.

GIF Escopos.
Ou seja, uma fun√ß√£o √© capaz de segurar em seu escopo uma vari√°vel de tipo var, mas trechos de c√≥digo que sejam estruturas condicionais e/ou de repeti√ß√£o n√£o s√£o capazes de fazer o mesmo. Logo se temos uma vari√°vel var em um trecho de c√≥digo em escopo global , ou seja, fora de uma fun√ß√£o, ela vai "vazar" se tornando tamb√©m global, assim como o trecho de c√≥digo.
Outro grande problema ao utilizar o var para atribuir valor √† vari√°veis √© que voc√™ consegue sobrescrev√™-las sem gerar erros.
Copiar
var userName = 'Isabella';
var userName = 'Lucas';
console.log(userName); // Resultado: Lucas
Em aplica√ß√µes maiores ao usar o var, voc√™ pode redeclarar vari√°veis acidentalmente e nem perceber o que aconteceu. Por isso, encontrar e corrigir bugs pode se tornar uma verdadeira miss√£o imposs√≠vel. ‚ö†Ô∏è Por estes motivos, declarar vari√°veis com o var n√£o √© uma boa pr√°tica.
O ES6 corrige esse problema ao introduzir o let e o const, fazendo com que uma vari√°vel, com um nome espec√≠fico, s√≥ possa ser declarada uma √∫nica vez dentro de um escopo. Experimente executar o exemplo anterior usando o let e const e veja o que acontece!
E quanto ao const, como ele se diferencia do let? O const permite que voc√™ declare constantes. Em outras palavras, o valor atribu√≠do a uma vari√°vel declarada com o const n√£o pode ser alterado. J√° quando usamos o let, podemos substituir o valor original atribu√≠do √† vari√°vel. Tente executar o c√≥digo abaixo usando o const e let e veja o que acontece!
Copiar
const favoriteLanguage = 'Javascript';
favoriteLanguage = 'Python';
console.log(favoriteLanguage); // Erro

let favoriteTechnology = 'Machine learning';
favoriteTechnology = 'Facial recognition';
console.log(favoriteTechnology); // Facial recognition
No exemplo acima, vimos que o const √© imut√°vel - ao declarar const favoriteLanguage = 'Javascript' o valor de favoriteLanguage n√£o pode ser alterado. Mas quando usamos o const para criar um objeto, o Javascript nos permite alterar as suas propriedades sem, contudo, reatribuir um novo objeto. Acompanhe o exemplo abaixo para entender melhor como funciona:
Copiar
const userInfo = {
  name: 'Cl√°udio',
  id: '5489-2',
  email: 'claudio@email.com',
};

userInfo.name = 'Jo√£o';

console.log(userInfo); // { name: 'Jo√£o', id: '5489-2', email: 'claudio@email.com' }
Esse racioc√≠nio tamb√©m se aplica a um array. Podemos alter√°-lo indiretamente adicionando/removendo um novo item sem sobrescrever o que j√° foi declarado:
Copiar
const technologies = ['Javascript', 'CSS', 'HTML'];
technologies.push('React');
console.log(technologies); // [ 'Javascript', 'CSS', 'HTML', 'React' ]

technologies = ['Javascript', 'CSS', 'HTML', 'React']
console.log(technologies); // Erro
Hoisting
Hoisting √© um comportamento padr√£o do JavaScript que acontece com vari√°veis declaradas com var. Esse comportamento move todas as declara√ß√µes destas vari√°veis para o topo do escopo global, independentemente de onde a declara√ß√£o foi feita.
Veja o exemplo abaixo:
Copiar
age = 20;

var age;

console.log(age); // 20
Mesmo atribuindo um valor √† vari√°vel age antes mesmo de declar√°-la, o console.log conseguiu imprimir o seu valor, isso por causa do hoisting. √â como se tiv√©ssemos primeiro declarado a vari√°vel age e depois atribu√≠do o valor 20, como no exemplo abaixo:
Copiar
var age;

age = 20;

console.log(age); // 20
Por√©m, apenas a declara√ß√£o da vari√°vel √© movida para o topo do escopo e n√£o seu valor. No c√≥digo abaixo podemos ver um exemplo disso. Ao atribuirmos um valor √† vari√°vel age apenas ap√≥s o console.log, recebemos undefined como resultado.
Copiar
var age;

console.log(age); // undefined

age = 20;
N√£o se esque√ßa de que esse comportamento acontece apenas com vari√°veis declaradas com var. Se tentarmos fazer isso com let ou const, ir√° dar erro.
Em resumo, vari√°veis podem ser declaradas com o const, let e var. Apesar das tr√™s terem o mesmo prop√≥sito, √© importante nos atentar √†s boas pr√°ticas para escrevermos c√≥digos confi√°veis. Assim, sempre que poss√≠vel, usar o const para declarar vari√°veis √© interessante porque conseguimos um comportamento mais previs√≠vel, j√° que o seu valor n√£o pode ser alterado diretamente.




Parte II - template literals
template literals √© mais uma feature do ES6 que nos permite criar strings complexas de forma mais f√°cil. Voc√™ certamente j√° concatenou strings e vari√°veis em Javascript da seguinte forma:
Copiar
const myName = 'Isabella';
console.log('Hello' + ' ' + myName + '!');
Essa solu√ß√£o nada elegante √© como faz√≠amos antes do ES6 introduzir uma nova forma de criar e manipular strings dinamicamente atrav√©s de template literals. Com o template literals o exemplo acima pode ser substitu√≠do por:
Copiar
const myName = 'Isabella';
console.log(`Welcome ${myName}!`);
A sintaxe do template literals pede para usarmos o sinal de crases no in√≠cio e no final da frase, e vari√°veis dentro de um ${...}. Voc√™ tamb√©m pode adicionar uma express√£o dentro das chaves, como ${a + b}. Outra novidade √© poder adicionar quebras de linha com o template literals sem a necessidade de concaten√°-las com o operador + e \n para trocar de linha. Execute o c√≥digo abaixo para ver o resultado!
Copiar
// Com o template literals
console.log(`Primeira linha;
Segunda linha;
Terceira linha;`
);

// Sem o template literals:
console.log('Primeira linha;\n' + 'Segunda linha;\n' + 'Terceira linha;\n');
Para refor√ßar ainda mais esse conceito de template literals, assista ao v√≠deo abaixo:

Agora voc√™ j√° est√° pronto para escrever c√≥digos mais limpos e leg√≠veis usando template literals!




Parte III - arrow functions
Voc√™ j√° est√° craque em declarar fun√ß√µes em JavaScript utilizando a seguinte sintaxe:
Copiar
const printName = function () {
  const myName = 'Lucas';
  return myName;
};

console.log(printName());
A express√£o acima est√° correta. Mas como voc√™ ver√° nos exemplos a seguir, √© poss√≠vel deix√°-la ainda mais direta e l√©xica. Voc√™ aprender√° com alguns exemplos as vantagens de usarmos mais essa novidade do Javascript ES6 - arrow functions. Uma das aplica√ß√µes para arrow functions √© em fun√ß√µes an√¥nimas. Em Javascript, √© muito comum n√£o precisarmos nomear fun√ß√µes, como mostrado no exemplo acima. Isso pode acontecer quando criamos fun√ß√µes que n√£o ser√£o reutilizadas, ou que ser√£o passadas como argumento para uma outra fun√ß√£o. Chamamos fun√ß√µes sem um nome espec√≠fico de fun√ß√µes an√¥nimas.
Primeiramente, assista ao v√≠deo a seguir.

arrow functions nada mais √© do que uma forma diferente de se declarar fun√ß√µes escrevendo menos c√≥digo. Veja abaixo como ficaria a fun√ß√£o printName utilizando a sintaxe da arrow function:
Copiar
const printName = () => {
  const myName = 'Lucas';
  return myName;
};

console.log(printName());
Quando n√£o h√° nada no corpo da fun√ß√£o al√©m do que ser√° retornado, a sintaxe da arrow function nos permite simplificar ainda mais a fun√ß√£o printName omitindo o return e as chaves:
Copiar
const printName = () => 'Lucas';
console.log(printName());
Mas lembre-se que podemos omitir os par√™nteses apenas em um cen√°rio:
Quando a fun√ß√£o recebe apenas um argumento, como podemos ver no exemplo abaixo:
Copiar
const multiplyByTwo = number => number * 2;
console.log(multiplyByTwo(10));
Em fun√ß√µes que recebem mais de um par√¢metro, os par√™nteses n√£o s√£o omitidos:
Copiar
const multiplication = (number, multi) => number * multi;
console.log(multiplication(8, 2));




Parte IV - ternary operator
At√© o momento voc√™ j√° aprendeu a usar express√µes if/else e switch/case pra executar c√≥digo baseado em certas condi√ß√µes, correto? Mas e se te diss√©ssemos que existe uma sintaxe mais simples para a constru√ß√£o de algumas condicionais no JavaScript e que combina muito bem com as novas altera√ß√µes do ES6?
Pois √©! Al√©m dos condicionais que voc√™ j√° aprendeu, o JavaScript traz consigo uma ferramenta que permite fazer opera√ß√µes condicionais mais simples, que s√≥ tenham duas possibilidades de resposta (x se verdadeiro, y se falso), com uma sintaxe simplificada e leg√≠vel: o operador tern√°rio. Ele funciona muito bem com as sintaxes simplificadas que voc√™ acabou de aprender, como arrow functions, por exemplo! Para entend√™-lo melhor, observe a seguinte l√≥gica:
Copiar
// A sintaxe b√°sica do operador tern√°rio √© muito simples:
`express√£o verdadeira ou falsa` ? `retorno se verdadeira` : `retorno se falsa`;

// Assim, por exemplo, podemos ter express√µes com a seguinte estrutura:
const trueExpression = (1 + 1 === 2) ? `isso √© verdade` : `isso √© mentira`;
console.log(trueExpression); // isso √© verdade

const falseExpression = (2 + 2 === 3) ? `isso √© verdade` : `isso √© mentira`;
console.log(falseExpression); // isso √© mentira
Como voc√™ pode ver, a sintaxe do operador tern√°rio √© bem simples: x ? y : z.
O x √© uma condi√ß√£o que ser√° avaliada como verdadeira ou falsa;
O y √© o retorno se a condi√ß√£o for verdadeira;
O z √© o retorno se a condi√ß√£o for falsa;
A vantagem do operador tern√°rio √© que ele √© f√°cil de entender quando se pega o jeito e √© muito mais sucinto do que escrever um bloco condicional com if/else ou switch, gerando um c√≥digo mais limpo e simples.
Por outro lado, √© bom saber que o operador tern√°rio n√£o substitui as express√µes condicionais tradicionais! Em qualquer situa√ß√£o onde exista mais de uma condi√ß√£o a ser avaliada, gerando tr√™s ou mais resultados poss√≠veis, o mais simples ser√° utilizar as op√ß√µes j√° aprendidas anteriormente:
Copiar
// Situa√ß√£o em que √© mais simples usar o operador tern√°rio:
const checkIfElse = (age) => {
  if (age >= 18) {
    return `Voc√™ tem idade para dirigir!`;
  } else {
    return `Voc√™ ainda n√£o tem idade para dirigir...`;
  }
};

const checkTernary = (age) => (
  age >= 18 ? `Voc√™ tem idade para dirigir!` : `Voc√™ ainda n√£o tem idade para dirigir...`;
);

// ------------------------

// Situa√ß√£o em que usar o operador tern√°rio n√£o faz muito sentido:
const checkIfElse = (fruit) => {
  if (fruit === `ma√ß√£`) {
    return `Essa fruta √© vermelha`;
  } else if (fruit === `banana`) {
    return `Esta fruta √© amarela`;
  } else {
    return `N√£o sei a cor`;
  }
};

const checkTernary = (fruit === `ma√ß√£`) ? `Essa fruta √© vermelha`
  : ((fruit === `banana`) ? `Esta fruta √© amarela` : `N√£o sei a cor`);

// Aninhar operadores  tern√°rios, como no exemplo acima, n√£o √© uma boa pr√°tica,
// pois torna o seu c√≥digo truncado e dif√≠cil de ler, tirando todo o sentido de um
// operador cujo objetivo √© facilitar a sua vida e a da pessoa que ler√° seu c√≥digo
// no futuro!
Se voc√™ quiser refor√ßar ainda mais o conceito sobre operador tern√°rio e ainda receber uma super dica de como realizar apenas uma verifica√ß√£o para casos verdadeiros, assista ao v√≠deo abaixo üòâ:

No mais, vale dizer que o ternary operator √© uma excelente adi√ß√£o √† caixa de ferramentas de qualquer pessoa desenvolvedora, basta saber us√°-lo para tornar o c√≥digo mais simples e leg√≠vel!




Vamos praticar!
Agora que voc√™ j√° ficou fera nos recursos do ES6, que tal vermos algumas aplica√ß√µes juntinhos? üíö
Aula ao vivo! Vamos para o Slack, onde o link estar√° dispon√≠vel.



Parte I
Agora voc√™ vai fazer alguns exerc√≠cios de fixa√ß√£o.
üöÄ Se liga nesse foguete!
Os exerc√≠cios destacados com üöÄ s√£o os fundamentais pra voc√™ ir bem no projeto! Todos os exerc√≠cios v√£o contribuir com sua forma√ß√£o mas fique de olho nesses! üëÄ
Dica: Para a resolu√ß√£o dos exerc√≠cios voc√™ dever√° aplicar conceitos sobre arrays, principalmente utilizar o for.
üöÄ Altere o tipo das vari√°veis(var) para let ou const para que respeitem o escopo em que foram declaradas, e altere a fun√ß√£o utilizando arrow function e template literals.
Modifique a estrutura da fun√ß√£o para que ela seja uma arrow function;
Modifique as vari√°veis para que respeitem o escopo onde est√£o declaradas;
Modifique as concatena√ß√µes para template literals.
Copie o c√≥digo abaixo:
Copiar
      function testingScope(escopo) {
        if (escopo === true) {
          var ifScope = 'N√£o devo ser utilizada fora do meu escopo (if)';
          ifScope = ifScope + ' √≥timo, fui utilizada no escopo !';
          console.log(ifScope);
        } else {
          var elseScope = 'N√£o devo ser utilizada fora meu escopo (else)';
          console.log(elseScope);
        }
        console.log(ifScope + ' o que estou fazendo aqui ? :O'); // Se necess√°rio esta linha pode ser removida.
      }

      testingScope(true);
üöÄ Crie uma fun√ß√£o que retorne um array em ordem crescente.
Copie o c√≥digo abaixo:
Copiar
    const oddsAndEvens = [13, 3, 4, 10, 7, 2];

    const sortOddsAndEvens = () => {

    // Seu c√≥digo aqui.

    };

    console.log(oddsAndEvens); // ser√° necess√°rio alterar essa linha üòâ
Crie uma fun√ß√£o que fa√ßa com que o array oddsAndEvens fique em ordem crescente;
Utilize template literals para que a chamada console.log(<seu c√≥digo>oddsAndEvens<seu c√≥digo>); retorne a frase "Os n√∫meros 2,3,4,7,10,13 se encontram ordenados de forma crescente!".
B√¥nus (opcional): tente fazer o mesmo exerc√≠cio utilizando o m√©todo array.sort(). Spoiler: √â poss√≠vel realizar uma fun√ß√£o que ordene qualquer array de n√∫meros.




Parte II
Abaixo, voc√™ ver√° algumas especifica√ß√µes de algoritmos para desenvolver. √â fundamental que voc√™ utilize o que aprendeu sobre let, const, arrow functions, template literals e ternary operator.
Crie uma fun√ß√£o que receba um n√∫mero e retorne seu fatorial.
Na matem√°tica, o fatorial de um n√∫mero inteiro e positivo N, representado por N!, √© o produto de todos os seus antecessores at√© o n√∫mero um. Exemplo: 4! = 4 * 3 * 2 * 1 = 24.
Com base nessas informa√ß√µes:
Crie a fun√ß√£o factorial que recebe um n√∫mero como par√¢metro, utilizando arrow functions (Lembre-se de armazenar a fun√ß√£o utilizando o tipo de vari√°vel correta).
Dentro da fun√ß√£o crie uma vari√°vel result.
Crie a l√≥gica para retornar o fatorial de N!.
Imprima no terminal "Esse √© o fatorial resultado da fun√ß√£o" (Lembre-se de utilizar template literals nesse momento).
Dica: Armazene a chamada da fun√ß√£o em uma var√≠avel para imprimir no terminal seu resultado.
B√¥nus: tente fazer o mesmo exerc√≠cio de forma recursiva. Spoiler: √â poss√≠vel resolver com uma linha usando ternary operator.
Crie uma fun√ß√£o que receba uma frase como par√¢metro e retorne a maior palavra da frase.
Exemplo:
Copiar
      longestWord('Ant√¥nio foi no banheiro e n√£o sabemos o que aconteceu') // retorna 'aconteceu'
Dica: Nesse exerc√≠cio ser√° necess√°rio utilizar os conhecimentos sobre array, m√©todo split e loop for/of.
B√¥nus (opcional): tente fazer o mesmo exerc√≠cio utilizando o m√©todo array.sort().
üöÄ Crie uma p√°gina HTML que possua um contador de cliques.
Al√©m da estrutura b√°sica do HTML, sua p√°gina deve possuir:
Uma tag que receber√° o valor atualizado da quantidade de clicks do bot√£o.
Um bot√£o com o texto click aqui!, que receber√° um event listener do tipo click;
Na estrutura do script (dentro do HTML ou em um arquivo de JavaScript ):
Crie uma vari√°vel clickCount que ir√° acumular o n√∫mero de clicks do bot√£o;
Crie a l√≥gica do evento, para que a cada click no bot√£o seja adicionado o valor de 1. Exemplo: Caso n√£o tenha sido realizado nenhum click, o valor renderizado ser√° de 0. Caso o bot√£o seja clicado 5 vezes o valor renderizado no HTML ser√° de 5.
Dica: Nesse exerc√≠cio utilize document. getElementById para retornar o elemento do DOM que deseja.
üöÄ Crie duas fun√ß√µes JavaScript com as seguintes especifica√ß√µes:
N√£o se esque√ßa de usar template literals
Fun√ß√£o 1: Escreva uma fun√ß√£o que substitua a letra 'x' em uma frase.
O nome da fun√ß√£o dever√° ser substituaX;
A fun√ß√£o dever√° receber um nome por par√¢metro;
Declare dentro da fun√ß√£o uma vari√°vel do tipo const, com o nome frase, atribuindo o valor 'Tryber x aqui!';
A fun√ß√£o dever√° retornar uma nova frase onde o x da frase 'Tryber x aqui!' seja substitu√≠do pelo nome passado por par√¢metro.
Exemplo:
Par√¢metro: 'Bebeto'
Retorno: 'Tryber Bebeto aqui!'
Spoiler: O m√©todo split() pode ser utilizado de diferentes maneiras, como separar as palavras de um texto.
Fun√ß√£o 2: Escreva uma fun√ß√£o que ir√° receber o retorno da Fun√ß√£o 1 por par√¢metro e retornar√° uma nova string.
O nome da fun√ß√£o dever√° ser minhasSkills;
A fun√ß√£o dever√° receber o retorno da Fun√ß√£o 1 - substituaX por par√¢metro;
Declare dentro da fun√ß√£o uma vari√°vel com o nome skills, do tipo const;
A vari√°vel skills dever√° ser um array contendo tr√™s strings com tecnologias que voc√™ j√° aprendeu.
Crie uma var√°vel do tipo let e concatene o valor retornado da Fun√ß√£o 1 - substituaX (utilize template literals), a frase 'Minhas tr√™s principais habilidades s√£o:' e o valor da vari√°vel skills.
Exemplo de retorno:
Tryber Bebeto aqui!
Minhas tr√™s principais habilidades s√£o:
JavaScript
HTML
CSS



