O que vamos aprender?
Hoje voc√™ vai aprender sete features do ES6 que s√£o muito √∫teis na hora de desenvolver uma aplica√ß√£o:
spread operator;
par√¢metro rest;
object destructuring;
array destructuring;
default destructuring;
abbreviation object literal;
default params.


Voc√™ ser√° capaz de:
Aplicar corretamente spread operator;
Aplicar corretamente par√¢metro rest;
Aplicar corretamente object destructuring;
Aplicar corretamente array destructuring;
Aplicar corretamente default destructuring;
Aplicar corretamente abbreviation object literal;
Aplicar corretamente default params.



Por que isso √© importante?
Como vimos no bloco passado, o ES6 introduziu v√°rias features que contribuem para melhorar a escrita do seu c√≥digo. Hoje vamos aprender mais alguns recursos que voc√™ definitivamente vai querer ter na sua caixa de ferramentas! Saber us√°-los te ajudar√° a escrever c√≥digos mais concisos e limpos, facilitando a compreens√£o de quem for l√™-lo futuramente. Object destructuring, por exemplo, √© muito √∫til na hora de realizar uma tarefa recorrente de pessoa desenvolvedora: selecionar certos campos vindos da resposta de uma API. Com object destructuring voc√™ consegue declarativamente realizar essa tarefa, deixando seu c√≥digo mais leg√≠vel



Spread Operator
Como voc√™ faria para adicionar itens a um array? Voc√™ pode ter pensado em usar o push, como no exemplo abaixo:
Copiar
const numbers = [1, 2, 3];
numbers.push(4);

console.log(numbers); // [1, 2, 3, 4]
Essa solu√ß√£o √© v√°lida, e o seu racioc√≠nio est√° correto! Mas... Onde foi parar o array original numbers? Observe que quando usamos o push para adicionar algo a um array, ele ser√° sobrescrito. Neste exemplo simples, sobrescrever o array numbers n√£o foi um problema. No entanto, em aplica√ß√µes maiores em que voc√™ precisa atualizar alguma informa√ß√£o de um array ou objeto, voc√™ pode querer manter as informa√ß√µes originais e apenas criar uma c√≥pia do array original com o que precisa ser alterado. Em cen√°rios como esse, vamos deixar o push de lado e usar um recurso incr√≠vel para adicionar valores a objetos iter√°veis: o operador spread. Voc√™ se lembra do Object.assign? Pois bem, ao utilizar o operador spread, voc√™ pode obter o mesmo resultado do Object.assign, por√©m de uma forma mais simples pois √© poss√≠vel utilizar uma sintaxe mais curta. E n√£o para por a√≠! Voc√™ ver√° que o operador spread pode ser utilizado para combinar objetos e arrays, para copiar valores de objetos iter√°veis e tamb√©m em fun√ß√µes que recebem m√∫ltiplos argumentos.
Primeiramente, assista a este v√≠deo que explica o operador spread.

Como vimos no v√≠deo, o operador spread √© um recurso do ES6 que nos permite espalhar os valores de um objeto iter√°vel, como um array, em um novo objeto. Dessa forma, apenas copiamos as informa√ß√µes do array original e colamos em outro lugar. Acompanhe o exemplo num√©rico abaixo para fixar melhor a ideia do spread:
Copiar
const numbers = [1, 2, 3];

const newArray = [...numbers, 4, 5, 6];
console.log(newArray); // [ 1, 2, 3, 4, 5, 6 ]
console.log(numbers); // [ 1, 2, 3 ]
Muito legal, n√©? E voc√™ pode usar o spread em outra posi√ß√£o de newArray. Experimente passar o ...numbers no final do array e veja o que acontece. O spread √© muito √∫til tamb√©m quando precisamos combinar arrays em uma √∫nica estrutura, como ilustrado abaixo:
Copiar
const spring = ['OUT', 'NOV', 'DEZ'];
const summer = ['JAN', 'FEV', 'MAR'];
const fall = ['ABR', 'MAI', 'JUN'];
const winter = ['JUL', 'AGO', 'SET'];

const months = [...summer, ...fall, ...winter, ...spring];
console.log(months); /* [
  'JAN', 'FEV', 'MAR',
  'ABR', 'MAI', 'JUN',
  'JUL', 'AGO', 'SET',
  'OUT', 'NOV', 'DEZ'
] */
Outro uso interessante do spread √© no argumento de uma fun√ß√£o que recebe v√°rios par√¢metros. No pr√≥ximo exemplo, temos uma fun√ß√£o que calcula o IMC (√≠ndice de massa corporal) de um paciente. A fun√ß√£o recebe como par√¢metros o peso e a altura da pessoa, e retorna o resultado arredondado do IMC. Podemos salvar os dados do paciente em um array e utilizar o spread para expandir esses valores no argumento da fun√ß√£o que calcula o IMC:
Copiar
const imc = (peso, altura) => (peso / (altura * altura)).toFixed(2);
const patientInfo = [60, 1.7];

console.log(imc(...patientInfo)); // 20.76
E voc√™ pode aplicar esse conceito em fun√ß√µes prontas do Javascript que recebem m√∫ltiplos par√¢metros, como as fun√ß√µes Math.max e Math.min. Vamos ver um exemplo?
Copiar
const randomNumbers = [57, 8, 5, 800, 152, 74, 630, 98, 40];

console.log(Math.max(...randomNumbers)); // 800
console.log(Math.min(...randomNumbers)); // 5
Outro exemplo que pode ser v√°lido para a sua compreens√£o √© que voc√™ tamb√©m pode fazer o mesmo com objetos. Veja o exemplo abaixo:
Copiar
const people = {
  id: 101,
  name: 'Alysson',
  age: 25,
};

const about = {
  address: 'Av. Get√∫lio Vargas, 1000',
  occupation: 'Developer',
};

const customer = { ...people, ...about };
console.log(customer); /* {
  id: 101,
  name: 'Alysson',
  age: 25,
  address: 'Av. Get√∫lio Vargas, 1000',
  occupation: 'Developer'
} */
Para fixar
Para fixar e praticar, vamos fazer uma salada de frutas com itens adicionais que voc√™ desejar. Fa√ßa uma fun√ß√£o chamada fruitSalad passando como par√¢metro specialFruit e additionalItens, fa√ßa a fun√ß√£o retornar uma lista √∫nica contendo todos os itens da nossa salada de frutas usando o spread.
Copiar
// Fa√ßa uma lista com as suas frutas favoritas
const specialFruit = ['', '', ''];

// Fa√ßa uma lista de complementos que voc√™ gostaria de adicionar
const additionalItens = ['', '', ''];

const fruitSalad = (fruit, additional) => {
  // Esreva sua fun√ß√£o aqui
};

console.log(fruitSalad(specialFruit, additionalItens));
Lembre-se de continuar praticando e dar asas para a sua imagina√ß√£o com outras possibilidades.




Par√¢metro Rest
Agora que voc√™ viu como funciona o spread operator, vamos aprender mais um recurso que ir√° te auxiliar a criar fun√ß√µes que recebem um n√∫mero ilimitado de argumentos: o par√¢metro rest.
O par√¢metro rest √© uma feature do ES6 que permite com que voc√™ crie fun√ß√µes que recebam um n√∫mero vari√°vel de argumentos. Assim, suas fun√ß√µes ficam mais flex√≠veis. Os argumentos que ser√£o passados como par√¢metro s√£o salvos em um array que pode ser acessado de dentro da fun√ß√£o. Por isso, podemos passar qualquer tipo de par√¢metro quando usamos o rest. Todos eles ser√£o colocados dentro de um array, o que te permite usar m√©todos como o .length. Acompanhe o exemplo abaixo para entender melhor essa ideia:
Copiar
function quantosParams(...args) {
  console.log('par√¢metros:', args);
  return `Voc√™ passou ${args.length} par√¢metros para a fun√ß√£o.`;
}

console.log(quantosParams(0, 1, 2)); // Voc√™ passou 3 par√¢metros para a fun√ß√£o.
console.log(quantosParams('string', null, [1, 2, 3], { })); // Voc√™ passou 4 par√¢metros para a fun√ß√£o.
Observe no segundo console.log que passamos diferentes tipos de argumentos para a fun√ß√£o quantosParams e todos foram colocados em um array. Quer ver mais um exemplo onde o rest √© muito √∫til? Acompanhe!
Copiar
const sum = (...args) => args.reduce((accumulator, current) => accumulator + current, 0);
console.log(sum(4, 7, 8, 9, 60)); // 88
N√≥s j√° aprendemos sobre higher order functions e vimos como o m√©todo reduce √© √∫til para somar os elementos de um array. No exemplo acima, a fun√ß√£o sum calcula a soma de todos os argumentos passados a ela - independente do n√∫mero. Como o par√¢metro rest "empacota" todos os argumentos em um array, podemos utilizar o reduce para somar tudo o que estiver dentro deste array. Experimente passar mais n√∫meros como argumento para a fun√ß√£o sum. Voc√™ ver√° que independente do n√∫mero de argumentos passados, a fun√ß√£o ir√° executar a soma. Sua fun√ß√£o √© muito mais flex√≠vel quando queremos passar m√∫ltiplos par√¢metros com o rest pois voc√™ n√£o precisa especificar quantos argumentos a fun√ß√£o ir√° receber!




Par√¢metro Rest
Agora que voc√™ viu como funciona o spread operator, vamos aprender mais um recurso que ir√° te auxiliar a criar fun√ß√µes que recebem um n√∫mero ilimitado de argumentos: o par√¢metro rest.
O par√¢metro rest √© uma feature do ES6 que permite com que voc√™ crie fun√ß√µes que recebam um n√∫mero vari√°vel de argumentos. Assim, suas fun√ß√µes ficam mais flex√≠veis. Os argumentos que ser√£o passados como par√¢metro s√£o salvos em um array que pode ser acessado de dentro da fun√ß√£o. Por isso, podemos passar qualquer tipo de par√¢metro quando usamos o rest. Todos eles ser√£o colocados dentro de um array, o que te permite usar m√©todos como o .length. Acompanhe o exemplo abaixo para entender melhor essa ideia:
Copiar
function quantosParams(...args) {
  console.log('par√¢metros:', args);
  return `Voc√™ passou ${args.length} par√¢metros para a fun√ß√£o.`;
}

console.log(quantosParams(0, 1, 2)); // Voc√™ passou 3 par√¢metros para a fun√ß√£o.
console.log(quantosParams('string', null, [1, 2, 3], { })); // Voc√™ passou 4 par√¢metros para a fun√ß√£o.
Observe no segundo console.log que passamos diferentes tipos de argumentos para a fun√ß√£o quantosParams e todos foram colocados em um array. Quer ver mais um exemplo onde o rest √© muito √∫til? Acompanhe!
Copiar
const sum = (...args) => args.reduce((accumulator, current) => accumulator + current, 0);
console.log(sum(4, 7, 8, 9, 60)); // 88
N√≥s j√° aprendemos sobre higher order functions e vimos como o m√©todo reduce √© √∫til para somar os elementos de um array. No exemplo acima, a fun√ß√£o sum calcula a soma de todos os argumentos passados a ela - independente do n√∫mero. Como o par√¢metro rest "empacota" todos os argumentos em um array, podemos utilizar o reduce para somar tudo o que estiver dentro deste array. Experimente passar mais n√∫meros como argumento para a fun√ß√£o sum. Voc√™ ver√° que independente do n√∫mero de argumentos passados, a fun√ß√£o ir√° executar a soma. Sua fun√ß√£o √© muito mais flex√≠vel quando queremos passar m√∫ltiplos par√¢metros com o rest pois voc√™ n√£o precisa especificar quantos argumentos a fun√ß√£o ir√° receber!




Array Destructuring
Agora que voc√™ entende como a desestrutura√ß√£o funciona, voc√™ pode estar se perguntando: ser√° que ela tamb√©m se aplica a arrays? Afinal de contas, arrays s√£o objetos iter√°veis e t√™m algumas similaridades com os objetos em Javascript... Este questionamento √© v√°lido, e a resposta √©: SIM! Podemos desestruturar arrays da mesma forma que desestruturamos objetos usando a nota√ß√£o para array destructuring.
Como vimos na sess√£o anterior, podemos utilizar a desestrutura√ß√£o para acessar valores de um objeto e atribu√≠-los a vari√°veis. Voc√™ certamente j√° acessou um valor de uma posi√ß√£o do array da seguinte forma:
Copiar
const arrayCountries = ['Brazil', 'Japan', 'China', 'Canada'];

const firstCountry = arrayCountries[0];
const secondCountry = arrayCountries[1];
const thirdCountry = arrayCountries[2];
const fourthCountry = arrayCountries[3];

console.log(firstCountry); // Brazil
console.log(secondCountry); // Japan
console.log(thirdCountry); // China
console.log(fourthCountry); // Canada
Com a desestrutura√ß√£o de array podemos declarar todas as vari√°veis contendo os nomes dos pa√≠ses usando apenas uma √∫nica linha de c√≥digo:
Copiar
const arrayCountries = ['Brazil', 'Japan', 'China', 'Canada'];
const [firstCountry, secondCountry, thirdCountry, fourthCountry] = arrayCountries;

console.log(firstCountry); // Brazil
console.log(secondCountry); // Japan
console.log(thirdCountry); // China
console.log(fourthCountry); // Canada
Para Fixar
1 - Produza o mesmo resultado do c√≥digo, por√©m utilizando o array destructuring para recolher a fun√ß√£o e a sauda√ß√£o.
Copiar
const saudacoes = ['Ol√°', (saudacao) => console.log(saudacao)];

saudacoes[1](saudacoes[0]); // Ol√°

// Produza o mesmo resultado acima, por√©m utilizando array destructuring
2 - A seguir, temos alguns valores que est√£o descritos em vari√°veis incoerentes. Atrav√©s da desestrutura√ß√£o de arrays, corrija os valores das vari√°veis.
Copiar
let comida = 'gato';
let animal = '√°gua';
let bebida = 'arroz';

console.log(comida, animal, bebida); // arroz gato √°gua

// Utilizando array destructuring, fa√ßa com que os valores apare√ßam nas vari√°veis correspondentes ao seu verdadeiro tipo
3 - array abaixo possui alguns n√∫meros que n√£o condizem com o conte√∫do que ele deveria possuir. Atrav√©s de array destructuring, fa√ßa com que existam apenas n√∫meros pares na vari√°vel numerosPares.
Copiar
let numerosPares = [1, 3, 5, 6, 8, 10, 12];

console.log(numerosPares); // [6, 8, 10, 12];

// Utilize array destructuring para produzir o resultado esperado pelo console.log abaixo




Default Destructuring
Agora voc√™ j√° sabe como aplicar desestrutura√ß√£o em objetos e arrays. Voc√™ se lembra do que acontece quando tentamos acessar:
uma propriedade que n√£o existe em um objeto?
um valor em uma posi√ß√£o inexistente em um array?
Ou seja:
Copiar
const person = {
  name: 'Jo√£o',
  lastName: 'Jr',
  age: 34,
};

const { nationality } = person;
Essa desestrutura√ß√£o funciona? E se funciona, qual o valor que aparece se fizer console.log(nationality)? Copie esse c√≥digo e teste voc√™ mesmo. üòâ
Como vimos nas sess√µes anteriores, quando tentamos acessar uma propriedade que n√£o existe, como nationality, o valor retornado √© undefined. E se voc√™ quisesse dar um valor padr√£o para nationality, caso essa propriedade n√£o exista no objeto? Voc√™ consegue atribuir esse valor padr√£o utilizando default destructuring, que √© mais um recurso do ES6:
Copiar
const person = {
  name: 'Jo√£o',
  lastName: 'Jr',
  age: 34,
};

const { nationality = 'Brazilian' } = person;
console.log(nationality); // Brazilian
Analogamente, o mesmo pode ser feito na hora de desestruturar um array:
Copiar
const position2d = [1.0, 2.0];
const [x, y, z = 0] = position2d;

console.log(x); // 1
console.log(y); // 2
console.log(z); // 0
Para Fixar
Do jeito que est√°, quando passamos person para a fun√ß√£o GetNationality o retorno √© Jo√£o is undefined. Ajuste a fun√ß√£o GetNationality para que a chamada GetNationality(person) retorne Jo√£o is Brazilian.
Copiar
const getNationality = ({ firstName, nationality }) => `${firstName} is ${nationality}`;

const person = {
  firstName: 'Jo√£o',
  lastName: 'Jr II',
};

const otherPerson = {
  firstName: 'Ivan',
  lastName: 'Ivanovich',
  nationality: 'Russian',
};

console.log(getNationality(otherPerson)); // Ivan is Russian
console.log(getNationality(person));




Object Property Shorthand
Voc√™ j√° deve ter percebido que uma das vantagens do ES6 √© que a nova sintaxe elimina c√≥digos repetitivos, contribuindo para a limpeza do c√≥digo. O property shorthand √© um recurso muito √∫til na hora de declarar objetos em Javascript. A fun√ß√£o abaixo recebe como par√¢metro informa√ß√µes sobre uma nova pessoa usu√°ria e retorna um objeto contendo esses dados. Observe que as propriedades do objeto retornado e os argumentos que passamos para newUser s√£o id√™nticos. Essa repeti√ß√£o parece desnecess√°ria, n√£o √© mesmo?
Copiar
const newUser = (id, name, email) => {
  return {
    id: id,
    name: name,
    email: email,
  };
};

console.log(newUser(54, 'isabella', 'isabella@email.com')); // { id: 54, name: 'isabella', email: 'isabella@email.com' }
√â exatamente essa repeti√ß√£o que a feature property shorthand elimina: podemos simplesmente substituir id: id por id que o Javascript entende que voc√™ quer atribuir o valor de id a uma propriedade com o mesmo nome que o par√¢metro passado:
Copiar
const newUser = (id, name, email) => {
  return {
    id,
    name,
    email,
  };
};

console.log(newUser(54, 'isabella', 'isabella@email.com')); // { id: 54, name: 'isabella', email: 'isabella@email.com' }
Muito legal, n√£o √© mesmo? Este √© mais um recurso que te permite escrever c√≥digos mais concisos!
Para Fixar
Agora √© hora de praticar: altere a fun√ß√£o getPosition utilizando a property shorthand.
Copiar
const getPosition = (latitude, longitude) => ({
  latitude: latitude,
  longitude: longitude});

console.log(getPosition(-19.8157, -43.9542));




Default Parameters
Por √∫ltimo, mas n√£o menos importante, vamos entender o que √© o par√¢metro default. Imagine que voc√™ queira executar a fun√ß√£o greeting abaixo, que imprime uma sauda√ß√£o para a pessoa usu√°ria. O que acontece quando voc√™ chama a fun√ß√£o sem passar o argumento que ela espera? Fa√ßa esse teste com o exemplo no seu editor de c√≥digos!
Copiar
const greeting = (user) => console.log(`Welcome ${user}!`);

greeting(); // Welcome undefined!
Voc√™ ver√° que a fun√ß√£o retornar√° undefined. Voc√™ consegue pensar em uma forma de corrigir esse problema? Afinal, podemos esquecer de chamar a fun√ß√£o com o nome da pessoa usu√°ria. Uma solu√ß√£o seria:
Copiar
const greeting = (user) => {
  const userDisplay = typeof user === 'undefined' ? 'pessoa usu√°ria' : user;
  console.log(`Welcome ${userDisplay}!`);
};

greeting(); // Welcome pessoa usu√°ria!
Essa solu√ß√£o n√£o parece muito elegante, n√£o √© mesmo? Afinal, precisamos incluir uma linha para checar se o par√¢metro √© indefinido. Se sim, definimos que user ser√° 'pessoa usu√°ria'. Caso contr√°rio, a fun√ß√£o ir√° imprimir a mensagem com o nome da pessoa usu√°ria passado como argumento.
Com o ES6, podemos pr√©-definir um par√¢metro padr√£o para a fun√ß√£o. Assim, podemos reescrever o exemplo anterior da seguinte forma:
Copiar
const greeting = (user = 'pessoa usu√°ria') => console.log(`Welcome ${user}!`);

greeting(); // // Welcome pessoa usu√°ria!
Simples assim! Passar um par√¢metro como default √© um pequeno detalhe que torna o seu c√≥digo muito mais sem√¢ntico. Assim, o default ser√° utilizado caso nenhum argumento seja fornecido a fun√ß√£o. Voc√™ pode adicionar mais de um par√¢metro default caso a sua fun√ß√£o receba v√°rios argumentos, se achar necess√°rio.
Para Fixar
Para praticar, escreva uma fun√ß√£o multiply que multiplique dois n√∫meros passados como argumentos. Atribua como default o valor 1 caso n√£o seja passado nenhum valor como segundo par√¢metro.
Copiar
const multiply = (number, value) => {
  // Escreva aqui a sua fun√ß√£o
};

console.log(multiply(8));




Vamos praticar!
Te apresentamos as üîßüî®, partiu pr√°tica!
Aula ao vivo! Vamos para o Slack onde o link estar√° dispon√≠vel.



Instru√ß√µes para realiza√ß√£o dos exerc√≠cios
Todos os exerc√≠cios cont√™m um c√≥digo base. Voc√™ dever√° copiar esse c√≥digo e salv√°-lo em um arquivo nomeado conforme o n√∫mero do exerc√≠cio. Por exemplo, o exerc√≠cio 1 deve ser salvo no arquivo exercise1.js, e assim por diante.
üöÄ Se liga nesse foguete!
Os exerc√≠cios destacados com üöÄ s√£o os fundamentais pra voc√™ ir bem no projeto! Todos os exerc√≠cios v√£o contribuir com sua forma√ß√£o mas fique de olho nesses! üëÄ



Instru√ß√µes para realiza√ß√£o dos exerc√≠cios
Todos os exerc√≠cios cont√™m um c√≥digo base. Voc√™ dever√° copiar esse c√≥digo e salv√°-lo em um arquivo nomeado conforme o n√∫mero do exerc√≠cio. Por exemplo, o exerc√≠cio 1 deve ser salvo no arquivo exercise1.js, e assim por diante.
üöÄ Se liga nesse foguete!
Os exerc√≠cios destacados com üöÄ s√£o os fundamentais pra voc√™ ir bem no projeto! Todos os exerc√≠cios v√£o contribuir com sua forma√ß√£o mas fique de olho nesses! üëÄ



Agora a pr√°tica
1 - Dado o c√≥digo abaixo, altere a chamada da fun√ß√£o rectangleArea de forma que seja impressa a √°rea dos 3 ret√¢ngulos (rectangle1, rectangle2 e rectangle3). O c√≥digo deve retornar em sequ√™ncia 2, 15 e 54.
Dica: use spread operator.
Copiar
const rectangleArea = (width, height) => width * height;

const rectangle1 = [1, 2];
const rectangle2 = [3, 5];
const rectangle3 = [6, 9];
const rectangles = [rectangle1, rectangle2, rectangle3];

rectangles.forEach((rectangle) => {
  console.log(rectangleArea(parametro)); // Altere o par√¢metro recebido por rectangleArea()
});
2 - Crie uma fun√ß√£o sum que dado um n√∫mero ilimitado de par√¢metros retorna a soma desses par√¢metros. Ao chamar a fun√ß√£o dessa forma : sum(4,5,6) o n√∫mero 15 deve ser retornado.
Dica: use par√¢metro rest.
Copiar
// escreva sum abaixo
3 - Escreva a fun√ß√£o personLikes, que dado um objeto de par√¢metro que representa uma pessoa (vari√°veis alex e gunnar), retorna todos os gostos daquela pessoa, conforme mostrado abaixo:
Dica: use object destructuring.
Copiar

<!-- name: nome da pessoa, age: idade, likes: gosta de, nationality: nacionalidade -->

const alex = {
  name: 'Alex',
  age: 26,
  likes: ['fly fishing'],
  nationality: 'Australian',
};

const gunnar = {
  name: 'Gunnar',
  age: 30,
  likes: ['hiking', 'scuba diving', 'taking pictures'],
  nationality: 'Icelandic',
};

// complete a assinatura da fun√ß√£o abaixo
const personLikes = () => `${name} is ${age} years old and likes ${likes.join(', ')}.`;

<!-- <nome> tem <anos de idade> e gosta de <gostos da pessoa> -->

<!-- Retornos esperados: -->
console.log(personLikes(alex)); // 'Alex is 26 years old and likes fly fishing.'
console.log(personLikes(gunnar)); // 'Gunnar is 30 years old and likes hiking, scuba diving, taking pictures.'
üöÄ 4 - Escreva uma fun√ß√£o filterPeople que, dada uma lista de pessoas, retorna todas as pessoas australianas que nasceram no s√©culo 20:
Dica: use object destructuring.
Copiar

const people = [
  {
    name: 'Nicole',
    bornIn: 1992,
    nationality: 'Australian',
  },
  {
    name: 'Harry',
    bornIn: 2008,
    nationality: 'Australian',
  },
  {
    name: 'Toby',
    bornIn: 1901,
    nationality: 'Australian',
  },
  {
    name: 'Frida',
    bornIn: 1960,
    nationality: 'Dannish',
  },
  {
    name: 'Fernando',
    bornIn: 2001,
    nationality: 'Brazilian',
  },
];
//bornIn: nascido em

// escreva filterPeople abaixo
5 - Escreva a fun√ß√£o swap, que dado um array de 3 elementos, retorna um novo array com o primeiro e terceiro elementos trocados. Detalhe: voc√™ precisa fazer essa fun√ß√£o gastando somente 1 linha. O retorno da fun√ß√£o utilizando o array myList deve ser [3, 2, 5].
Dica: use array destructuring.
Copiar
const myList = [5, 2, 3];

// escreva swap abaixo
6 - Suponha que voc√™ esteja lidando com carros e, da forma como o problema lhe foi entregue, cada carro √© representado dentro de um array. Ent√£o seu chefe pede que seja mudado o formato de array para objeto. Crie uma fun√ß√£o toObject que, dada uma lista, retorna um objeto representando o carro:
Dica: use array destructuring e abbreviation object literal.
Copiar
const palio = ['Palio', 'Fiat', 2019];
const shelbyCobra = ['Shelby Cobra', 'Ford', 1963];
const chiron = ['Chiron', 'Bugatti', 2016];

// escreva toObject abaixo
7 - Escreva uma fun√ß√£o shipLength que, dado um objeto representando um navio, retorna o comprimento dele, mostrando tamb√©m a devida unidade de medida:
Dica: use object destructuring.
Copiar
const ships = [
  {
    name: 'Titanic',
    length: 269.1,
    measurementUnit: 'meters',
  },
  {
    name: 'Queen Mary 2',
    length: 1132,
    measurementUnit: 'feet',
  },
  {
    name: 'Yamato',
    length: 256,
    measurementUnit: 'meters',
  },
];
// measurementUnit: unidade de medida

// escreva shipLength abaixo

console.log(shipLength(ships[0])); // 'Titanic is 269.1 meters long'
console.log(shipLength(ships[1])); // 'Queen Mary 2 is 1132 feet long'
console.log(shipLength(ships[2])); // 'Yamato is 256 meters long'
8 - Escreva uma fun√ß√£o greet que, dado o nome de uma pessoa, retorna uma mensagem de cumprimento:
Dica: use default params.
Copiar
// escreva greet abaixo

console.log(greet('John')) // 'Hi John'
console.log(greet('John', 'Good morning')) // 'Good morning John'
console.log(greet('Isabela', 'Oi')) // 'Oi Isabela'
9 - Existe um objeto yearSeasons que representam as esta√ß√µes do ano. Cada esta√ß√£o √© uma chave deste objeto e o valor de cada chave √© um array de strings, representando os meses daquela esta√ß√£o. A partir deste objeto, desestruture as esta√ß√µes do ano e espalhe-as em um array de meses do ano.
Dica: use object destructuring e spread operator.
OBS: As esta√ß√µes do ano aqui descritas t√™m base nas esta√ß√µes do hemisf√©rio norte.
Copiar
// yearSeasons: esta√ß√µes do ano.
const yearSeasons = {
  spring: ['March', 'April', 'May'],
  summer: ['June', 'July', 'August'],
  autumn: ['September', 'October', 'November'],
  winter: ['December', 'January', 'February'],
};




