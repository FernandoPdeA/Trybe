O que vamos aprender?
Parab√©ns pelo progresso! Vamos continuar avan√ßando, pois no dia de hoje daremos um importante passo nos seus conhecimentos de JavaScript. Vamos aprender os conceitos e as aplica√ß√µes das chamadas Higher Order Functions, tal qual compreender como podemos nos beneficiar desse valioso recurso na constru√ß√£o de c√≥digo.
Essas fun√ß√µes s√£o bastante poderosas, e podemos utiliz√°-las para implementar solu√ß√µes para diversos tipos de situa√ß√£o. Resultando em um c√≥digo mais leg√≠vel, conciso e expressivo.


Voc√™ ser√° capaz de:
Utilizar fun√ß√µes de diferentes formas;
Reutilizar l√≥gicas de c√≥digos;
Aplicar o conceito de Higher Order Functions.


Por que isso √© importante?
O grande benef√≠cio das Higher Order Functions, tamb√©m conhecidas como HOFs √© a maior capacidade de reutiliza√ß√£o de l√≥gicas j√° implementadas, uma vez que permitem a cria√ß√£o de fun√ß√µes mais robustas. Isso gera economia de c√≥digo e poupa o trabalho da pessoa desenvolvedora em reestruturar toda uma l√≥gica novamente.
Esse conhecimento pode fazer de voc√™ uma pessoa desenvolvedora mais solicitada no mercado, visto que as HOFs ir√£o auxiliar no conceito de Clean Code que √© bastante utilizado.


Conte√∫dos
A seguir voc√™ ir√° aprender o que √© first-class functions e quais os efeitos pr√°ticos em linguagens que utilizam esse conceito (JavaScript). Tamb√©m aprender√° o que s√£o High Order Functions e situa√ß√µes comuns onde s√£o empregadas.



First-Class Functions
Uma linguaguem √© dita ter First-Class Functions quando trata suas fun√ß√µes como first class citizens (isto √©, cidad√£os de primeira classe), ou seja, elas suportam as mesmas opera√ß√µes que est√£o dispon√≠veis para os outros tipos. Isso significa que nossas fun√ß√µes podem ser atribu√≠das √† vari√°veis, passadas como argumento e/ou retornadas por outras fun√ß√µes. JavaScript √© uma linguagem que utiliza esse conceito, portanto podemos:
Atribuir fun√ß√µes √† vari√°veis:
Copiar
function sum (number1, number2) {
  return number1 + number2;
}

const sumVariable = sum;

console.log(sumVariable);
//  [Function: sum]
No exemplo acima, vemos a declara√ß√£o da fun√ß√£o sum acontecendo e a atribui√ß√£o da mesma fun√ß√£o dentro de uma vari√°vel chamada sumVariable. Esse exemplo pode soar estranho. Voc√™ deve estar se perguntando: "criei uma fun√ß√£o pra colocar ela dentro de uma vari√°vel... por que fazer isso?". Caso voc√™ tenha tido esse questionamento, n√£o sinta-se perdido. O real motivo foi para exemplificar que podemos fazer.
Mas achou que ir√≠amos te deixar sem um exemplo concreto? Achou errado! Ali√°s, voc√™ j√° faz isso h√° algum tempo...
Copiar
const sum = (number1, number2) => {
  return number1 + number2;
};
Quando utilizamos arrow functions, estamos justamente utilizando da capacidade do javascript de conseguir armazenar a fun√ß√£o dentro de uma vari√°vel. Isso √© algo maravilhoso.
Passar fun√ß√µes como argumento para outras fun√ß√µes:
Copiar
const sayHello = () => {
  return ('hello trybers');
}

const printGreeting = (callback) => {
    console.log(callback());
}

printGreeting(sayHello);
Retornar uma fun√ß√£o de outra fun√ß√£o:
Copiar
const sumFixAmount = (amount) => {
  return (number) => amount + number;
}

const initialSum = sumFixAmount(15)
console.log(initialSum(5));



Higher Order Functions
Agora que j√° especificamos o que s√£o fun√ß√µes de primeira classe, vamos aprender sobre as Fun√ß√µes de Ordem Superior, conhecidas por Higher Order Functions ou simplesmente HOFs.
As HOFs s√£o fun√ß√µes que usam outras fun√ß√µes em suas opera√ß√µes, devendo aceit√°-las como par√¢metro e/ou retorn√°-las. O mais incr√≠vel √© que voc√™ j√° aplicou este conceito na pr√°tica. Veja este exemplo:
Copiar
const button = document.querySelector('#signup-button');

const registerUser = () => {
  console.log('Registrado com sucesso!');
};

button.addEventListener('click', registerUser);
Constru√≠mos uma fun√ß√£o que simula o registro de uma nova pessoa e passamos como argumento de uma segunda fun√ß√£o. Logo, addEventListener √© uma HOF.
Lembre-se: First-Class Functions √© o nome do conceito que define a forma que a linguagem (no nosso caso JavaScript) trata suas fun√ß√µes, permitindo que sejam suportadas em opera√ß√µes que s√£o usadas em outros tipos (atribui√ß√£o, retorno, par√¢metro), e HOF √© uma fun√ß√£o que atende ao crit√©rio de receber como par√¢metro e/ou retornar outra fun√ß√£o.
Agora que voc√™ viu o que s√£o fun√ß√µes de primeira classe e sua aplica√ß√£o em par√¢metros, partiu saber como estruturar suas HOFs?



Estruturando uma HOF
Vamos construir este conceito passo a passo para que voc√™ possa compreender e aplicar na sua jornada como pessoa desenvolvedora. Para isto, √© extremamente importante ter em mente que as HOFs nos permitem compactar a√ß√µes e n√£o somente repassar valores. Veja este exemplo:
Copiar
const repeat = (number, action) => {
  for (let count = 0; count <= number; count += 1) {
    action(count);
  }
};

repeat(5, console.log);
Constru√≠mos essa fun√ß√£o para implementar um la√ßo de repeti√ß√£o entre 0 e um n√∫mero especificado via par√¢metro (number) e para mostrar no console o valor da vari√°vel count de 0 a N (number). O console.log √© uma fun√ß√£o pr√≥pria do JavaScript, mas veja que fica mais simples caso voc√™ precise substituir esta a√ß√£o para console.table ou console.group.
Vamos aumentar um pouco o n√≠vel de complexidade e visualizar como podemos ir construindo fun√ß√µes mais especializadas e bem definidas. Veja este exemplo:
Copiar
const repeat = (number, action) => {
  for (let count = 0; count <= number; count += 1) {
    action(count);
  }
};

repeat(3, (number) => {
  if (number % 2 === 0) {
    console.log(number, 'is even');
  }
});
Pegamos a nossa implementa√ß√£o do exemplo anterior e repassamos dois par√¢metros ao chamarmos a fun√ß√£o repeat, sendo:
1 - Um n√∫mero at√© que ponto gostar√≠amos de testar, neste caso 3;
2 - Nossa a√ß√£o que ser√° executada quando chamada action(count) na nossa fun√ß√£o repeat, neste caso uma fun√ß√£o para testar nossos n√∫meros.
Veja que nosso segundo par√¢metro √© uma fun√ß√£o que recebe o count como argumento, proveniente da execu√ß√£o do nosso action(count) dentro da fun√ß√£o repeat. Deste modo, caso o count passe pela condi√ß√£o estabelecida para ser um n√∫mero par, ser√° executada a mensagem com os n√∫meros que atendem ao crit√©rio.
Pense agora que gostar√≠amos de testar quais n√∫meros s√£o √≠mpares. Veja como fica f√°cil ajustar a implementa√ß√£o:
Copiar
const repeat = (number, action) => {
  for (let count = 0; count <= number; count += 1) {
    action(count);
  }
};

const isEven = (number) => {
  if (number % 2 === 0) {
    console.log(number, 'is even');
  }
};

const isOdd = (number) => {
  if ((number % 2) > 0) {
    console.log(number, 'is odd');
  }
};

repeat(3, isEven); // Testa quais n√∫meros ser√£o pares;
repeat(3, isOdd); // Testa quais n√∫meros ser√£o √≠mpares;
Observe que apenas transportamos e ajustamos a l√≥gica para identificar os n√∫meros pares e √≠mpares em duas novas fun√ß√µes chamadas isEven e isOdd. Ap√≥s isso, s√≥ alteramos o segundo par√¢metro ao chamar a fun√ß√£o repeat.
A fun√ß√£o recebida como argumento pela HOF, tamb√©m √© conhecida por callback. No exemplo, repeat √© uma HOF que recebe isEven ou isOdd como callback. Podemos encontrar mais sobre este assunto nos Recursos adicionais, no entanto n√£o se preocupe com este conceito no momento, abordaremos isso nos conte√∫dos adiante.
Olhe o exemplo a seguir:
Copiar
const numberGenerator = () => {
  return Math.random() * 100;
}

console.log(numberGenerator);
Veja que ao executar esse c√≥digo, n√£o recebemos um n√∫mero aleat√≥rio. Isso aconteceu porque na quinta linha do script n√≥s imprimimos apenas a escrita da fun√ß√£o, como n√£o realizamos sua execu√ß√£o, ela n√£o seguiu os procedimentos para retornar um n√∫mero aleat√≥rio. Para executarmos a fun√ß√£o, ter√≠amos que inserir () na frente do numberGenerator.
Essa l√≥gica √© a mesma quando usamos callback dentro de outras fun√ß√µes. Lembre que o tra√ßo do JavaScript que considera fun√ß√µes como cidad√£s de primeira classe permite que n√≥s possamos inserir elas em vari√°veis. Voc√™ j√° fez isso antes tamb√©m, se voltar no primeiro exemplo dessa fun√ß√£o, vai ver que a chamada da callback no addEventListener funciona de modo similar. Tudo isso √© parte de algo maior, s√£o High Order Functions.

Para fixar
Vamos praticar com os seguintes exerc√≠cios:
1 - Crie uma fun√ß√£o que retorne a string 'Acordando!!';
2 - Crie outra fun√ß√£o que retorne a string 'Bora tomar caf√©!!';
3 - Crie mais uma fun√ß√£o que retorne a string 'Partiu dormir!!';
4 - Agora desenvolva uma HOF chamada doingThings e configure esta fun√ß√£o para que imprima no console o resultado da execu√ß√£o das fun√ß√µes que voc√™ criou nos exemplos anteriores. Exemplo:
Copiar
// Ao chamar a fun√ß√£o doingThings:
doingThings(wakeUp);

// Ela deve retornar o valor do respectivo par√¢metro, neste caso:
// Acordando!!



Vamos praticar!
√â hora de colocar em pr√°tica todo esse conhecimento. üí™
Aula ao vivo! Vamos para o Slack, onde o link estar√° dispon√≠vel.



Exerc√≠cios
Hora de p√¥r a m√£o na massa!
fundamentos
Antes de come√ßar: versionando seu c√≥digo
Para versionar seu c√≥digo, utilize o seu reposit√≥rio de exerc√≠cios. üòâ
Abaixo voc√™ vai ver exemplos de como organizar os exerc√≠cios do dia em uma branch, com arquivos e commits espec√≠ficos para cada exerc√≠cio. Voc√™ deve seguir este padr√£o para realizar os exerc√≠cios a seguir.
Abra a pasta de exerc√≠cios:
Copiar
$ cd ~/trybe-exercicios
Certifique-se de que est√° na branch main e ela est√° sincronizada com a remota. Caso voc√™ tenha arquivos modificados e n√£o comitados, dever√° fazer um commit ou checkout dos arquivos antes deste passo.
Copiar
$ git checkout main
$ git pull
A partir da main, crie uma branch com o nome exercicios/8.1 (bloco 8, dia 1)
Copiar
$ git checkout -b exercicios/8.1
Caso seja o primeiro dia deste m√≥dulo, crie um diret√≥rio para ele e o acesse na sequ√™ncia:
Copiar
$ mkdir fundamentos
$ cd fundamentos
Caso seja o primeiro dia do bloco, crie um diret√≥rio para ele e o acesse na sequ√™ncia:
Copiar
$ mkdir bloco-8-higher-order-functions-do-javascript-es6
$ cd bloco-8-higher-order-functions-do-javascript-es6
Crie um diret√≥rio para o dia e o acesse na sequ√™ncia:
Copiar
$ mkdir dia-1-javascript-es6-introducao-a-higher-order-functions
$ cd dia-1-javascript-es6-introducao-a-higher-order-functions
Os arquivos referentes aos exerc√≠cios deste dia dever√£o ficar dentro do diret√≥rio ~/trybe-exercicios/fundamentos/block-8-higher-order-functions-do-javascript-es6/dia-1-javascript-es6-introducao-a-higher-order-functions. Lembre-se de fazer commits pequenos e com mensagens bem descritivas, preferencialmente a cada exerc√≠cio resolvido.

Verifique os arquivos alterados/adicionados:
Copiar
$ git status
On branch exercicios/8.1
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   exercicio-1

Adicione os arquivos que far√£o parte daquele commit:
Copiar
# Se quiser adicionar os arquivos individualmente
$ git add caminhoParaArquivo

# Se quiser adicionar todos os arquivos de uma vez, por√©m, atente-se
para n√£o adicionar arquivos indesejados acidentalmente
$ git add --all

Fa√ßa o commit com uma mensagem descritiva das altera√ß√µes:
Copiar
$ git commit -m "Mensagem descrevendo altera√ß√µes"
Voc√™ pode visualizar o log de todos os commits j√° feitos naquela branch com git log.
Copiar
$ git log
commit 100c5ca0d64e2b8649f48edf3be13588a77b8fa4 (HEAD -> exercicios/8.1)
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 17:48:01 2019 -0300

    Exercicio 2 - mudando o evento de click para mouseover, tirei o alert e coloquei pra quando clicar aparecer uma imagem do lado direito da tela

commit c0701d91274c2ac8a29b9a7fbe4302accacf3c78
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 16:47:21 2019 -0300

    Exercicio 2 - adicionando um alert, usando fun√ß√£o e o evento click

commit 6835287c44e9ac9cdd459003a7a6b1b1a7700157
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 15:46:32 2019 -0300

    Resolvendo o exerc√≠cio 1 usando eventListener
Agora que temos as altera√ß√µes salvas no reposit√≥rio local precisamos envi√°-las para o reposit√≥rio remoto. No primeiro envio, a branch exercicios/8.1 n√£o vai existir no reposit√≥rio remoto, ent√£o precisamos configurar o remote utilizando a op√ß√£o --set-upstream (ou -u, que √© a forma abreviada).
Copiar
$ git push -u origin exercicios/8.1
Ap√≥s realizar o passo 9, podemos abrir a Pull Request a partir do link que aparecer√° na mensagem do push no terminal, ou na p√°gina do seu reposit√≥rio de exerc√≠cios no GitHub atrav√©s de um bot√£o que aparecer√° na interface. Escolha a forma que preferir e abra a Pull Request. De agora em diante, voc√™ repetir√° o fluxo a partir do passo 7 para cada exerc√≠cio adicionado, por√©m como j√° definimos a branch remota com -u anteriormente, agora podemos simplificar os comandos para:
Copiar
# Quando quiser enviar para o reposit√≥rio remoto
$ git push

# Caso voc√™ queria sincronizar com o remoto, poder√° utilizar apenas
$ git pull
Quando terminar os exerc√≠cios, seus c√≥digos devem estar todos commitados na branch exercicios/8.1, e dispon√≠veis no reposit√≥rio remoto do GitHub. Pra finalizar, compartilhe o link da Pull Request no canal de Code Review para a monitoria e/ou colegas revisarem. Fa√ßa review voc√™ tamb√©m, lembre-se que √© muito importante para o seu desenvolvimento ler o c√≥digo de outras pessoas. ü§úüèºü§õüèº



Agora a pr√°tica
1 - Crie uma fun√ß√£o que retorne um objeto no formato { nomeCompleto, email } representando uma nova pessoa contratada. Passe sua fun√ß√£o como par√¢metro da HOF newEmployees para criar cada pessoa contratada em seu respectivo id. A sua fun√ß√£o deve receber como par√¢metro o nome completo da pessoa funcion√°ria e a partir dele gerar automaticamente um email no formato nome_da_pessoa@trybe.com.
Copiar
const newEmployees = () => {
  const employees = {
    id1: '', // Nome: Pedro Guerra -> Chame sua fun√ß√£o passando o nome Pedro Guerra como par√¢metro, substituindo as aspas
    id2: '', // Nome: Luiza Drumond -> Chame sua fun√ß√£o passando o nome Luiza Drumond como par√¢metro, substituindo as aspas
    id3: '', // Nome: Carla Paiva -> Chame sua fun√ß√£o passando o nome Carla Paiva como par√¢metro, substituindo as aspas
  }
  return employees;
};
2 - Desenvolva uma HOF que retorna o resultado de um sorteio. Esta HOF ir√° gerar um n√∫mero aleat√≥rio entre 1 e 5 recebendo como par√¢metros o n√∫mero apostado e uma fun√ß√£o que checa se o n√∫mero apostado √© igual ao n√∫mero sorteado. O retorno da sua HOF deve ser uma string (Ex: "Tente novamente" ou "Parab√©ns voc√™ ganhou").
3 - Crie uma HOF que receber√° tr√™s par√¢metros:
O primeiro ser√° um array de respostas corretas (Gabarito);
O segundo ser√° um array contendo as respostas fornecidas por uma pessoa estudante;
O terceiro √© uma fun√ß√£o que compara os dois arrays e ent√£o d√° uma pontua√ß√£o baseada nos acertos. Para isso essa fun√ß√£o usar√° os seguintes crit√©rios:
Uma resposta correta adiciona 1 ponto √† pontua√ß√£o final;
A aus√™ncia de uma resposta n√£o altera a pontua√ß√£o (quando for "N.A");
Uma resposta incorreta reduz a pontua√ß√£o final em 0.5 ponto.
Ao final, a HOF deve retornar o total de pontos obtidos atrav√©s das respostas fornecidas pela pessoa estudante. Utilize os seguintes arrays:
Copiar
const RIGHT_ANSWERS = ['A', 'C', 'B', 'D', 'A', 'A', 'D', 'A', 'D', 'C'];
const STUDENT_ANSWERS = ['A', 'N.A', 'B', 'D', 'A', 'C', 'N.A', 'A', 'D', 'B'];




B√¥nus
Parte I - Game Actions Simulator
Nestes exerc√≠cios voc√™ ir√° implementar HOFs que simulam um turno de batalha em um jogo. Voc√™ ir√° criar fun√ß√µes que calculam dano, atualizam status, e ao final, retornam os resultados da rodada.
Para os pr√≥ximos exerc√≠cios copie o c√≥digo abaixo.
Copiar
const mage = {
  healthPoints: 130,
  intelligence: 45,
  mana: 125,
  damage: undefined,
};

const warrior = {
  healthPoints: 200,
  strength: 30,
  weaponDmg: 2,
  damage: undefined,
};

const dragon = {
  healthPoints: 350,
  strength: 50,
  damage: undefined,
};

const battleMembers = { mage, warrior, dragon };
1 - Crie uma fun√ß√£o que retorna o dano do drag√£o.
O dano ser√° um n√∫mero aleat√≥rio entre 15 (dano m√≠nimo) e o valor do atributo strength (dano m√°ximo).
2 - Crie uma fun√ß√£o que retorna o dano causado pelo warrior.
O dano ser√° um n√∫mero aleat√≥rio entre o valor do atributo strength (dano m√≠nimo) e o valor de strength * weaponDmg (dano m√°ximo).
3 - Crie uma fun√ß√£o que retorna um objeto com duas chaves e dois valores contendo o dano e a mana gasta pelo mago em um turno.
O dano ser√° um n√∫mero aleat√≥rio entre o valor do atributo intelligence (dano m√≠nimo) e o valor de intelligence * 2 (dano m√°ximo).
A mana consumida por turno √© 15. Al√©m disto a fun√ß√£o deve ter uma condicional, caso o mago tenha menos de 15 de mana o valor de dano recebe uma mensagem (Ex: "N√£o possui mana suficiente") e a mana gasta √© 0.
Parte II
Agora que voc√™ j√° possui a implementa√ß√£o das fun√ß√µes relativas aos tr√™s exerc√≠cios anteriores, passe-as como par√¢metro para outras fun√ß√µes que ir√£o compor um objeto gameActions. O objeto ser√° composto por a√ß√µes do jogo e cada a√ß√£o √© por denifi√ß√£o uma HOF, pois neste caso, s√£o fun√ß√µes que recebem como par√¢metro outra fun√ß√£o.
Copie o c√≥digo abaixo e inicie sua implementa√ß√£o:
Copiar
const gameActions = {
  // Crie as HOFs neste objeto.
};
1 - Crie a primeira HOF que comp√µe o objeto gameActions. Ela ser√° a fun√ß√£o que simula o turno do personagem warrior. Esta HOF receber√° como par√¢metro a fun√ß√£o que calcula o dano deferido pelo personagem warrior e atualizar√° os healthPoints do monstro dragon. Al√©m disto ela tamb√©m deve atualizar o valor da chave damage do warrior.
2 - Crie a segunda HOF que comp√µe o objeto gameActions. Ela ser√° a fun√ß√£o que simula o turno do personagem mage. Esta HOF receber√° como par√¢metro a fun√ß√£o que calcula o dano deferido pelo personagem mage e atualizar√° os healthPoints do monstro dragon. Al√©m disto ela tamb√©m deve atualizar o valor das chaves damage e mana do mage.
3 - Crie a terceira HOF que comp√µe o objeto gameActions. Ela ser√° a fun√ß√£o que simula o turno do monstro dragon. Esta HOF receber√° como par√¢metro a fun√ß√£o que calcula o dano deferido pelo monstro dragon e atualizar√° os healthPoints dos personagens mage e warrior. Al√©m disto ela tamb√©m deve atualizar o valor da chave damage do monstro.
4 - Adicione ao objeto gameActions uma fun√ß√£o que retorne o objeto battleMembers atualizado e fa√ßa um console.log para visualizar o resultado final do turno.



Recursos adicionais
Compreendendo Higher Order Functions
Uma introdu√ß√£o r√°pida √†s Higher Order Functions
Higher Order Functions - Eloquent JavaScript
Fun√ß√£o Callback
