O que vamos aprender?
Hoje vocÃª vai conhecer algumas HOFs que sÃ£o utilizadas com arrays. Essas funÃ§Ãµes sÃ£o bastante poderosas, podendo facilitar muito a manipulaÃ§Ã£o e criaÃ§Ã£o de arrays, resultando em um cÃ³digo mais legÃ­vel, conciso e expressivo.



VocÃª serÃ¡ capaz de:
Utilizar a funÃ§Ã£o Array.forEach para iterar sobre todos os elementos de um array;
Utilizar a funÃ§Ã£o Array.find para encontrar o primeiro elemento de um array que satisfaÃ§a a uma condiÃ§Ã£o;
Utilizar as funÃ§Ãµes Array.some e Array.every para testar se os elementos de um array satisfazem a uma condiÃ§Ã£o;
Utilizar a funÃ§Ã£o Array.sort para ordenar arrays de acordo com algum critÃ©rio.


Por que isso Ã© importante?
Arrays sÃ£o um dos tipos de dados mais importantes em qualquer linguagem, e com JavaScript nÃ£o Ã© diferente. Em qualquer programa nÃ£o trivial, vocÃª terÃ¡ que lidar com arrays de alguma forma, seja processando a resposta de uma requisiÃ§Ã£o a um servidor, seja iterando sobre o resultado de uma consulta a um banco de dados para realizar uma operaÃ§Ã£o sobre cada item, por exemplo.
Em suas Ãºltimas versÃµes, JavaScript vem adicionando funÃ§Ãµes que facilitam muito a criaÃ§Ã£o e manipulaÃ§Ã£o de arrays. Essas funÃ§Ãµes sÃ£o extremamente poderosas e ajudam a escrever cÃ³digo que Ã© mais legÃ­vel, expressivo, conciso, menos propenso a conter erros e, comumente, mais eficiente.
Esse tipo de funÃ§Ã£o nÃ£o Ã© exclusiva de JavaScript; elas tambÃ©m existem em outras linguagens modernas. EntÃ£o vocÃª precisa se acostumar com elas, pois as verÃ¡ com frequÃªncia no seu dia a dia. Depois de um pouco de prÃ¡tica, vocÃª nÃ£o conseguirÃ¡ viver sem elas!



ConteÃºdos
Recapitulando a aula anterior, uma Higher Order Function Ã© simplesmente uma funÃ§Ã£o que recebe outra funÃ§Ã£o como parÃ¢metro ou que retorna uma funÃ§Ã£o. VocÃª jÃ¡ vem utilizando funÃ§Ãµes assim desde o comeÃ§o do curso. Por exemplo, quando vocÃª escreve um cÃ³digo como este:
Copiar
const button = document.getElementById('button');
button.addEventListener('click', () => {
  console.log('Clicou no botÃ£o!');
});
VocÃª estÃ¡ passando como segundo parÃ¢metro para a funÃ§Ã£o addEventListener, uma funÃ§Ã£o contendo o cÃ³digo a ser executado quando o botÃ£o for clicado - no caso, a funÃ§Ã£o simplesmente imprime no console Clicou no botÃ£o!. EstÃ¡ vendo? VocÃª jÃ¡ usa HOFs sem saber. ğŸ¤“
A seguir, veremos algumas HOFs que estÃ£o disponÃ­veis em Arrays no JavaScript.



ImportÃ¢ncia das HOFs
"Mas por que isso Ã© importante?!" VocÃª deve estar se perguntando. AlÃ©m de event listeners, JavaScript possui vÃ¡rias outras funÃ§Ãµes desse tipo. Os arrays, em particular, possuem vÃ¡rias funÃ§Ãµes que facilitam sua criaÃ§Ã£o e manipulaÃ§Ã£o, alÃ©m de deixar seu cÃ³digo muito mais legÃ­vel e conciso.
Por exemplo: imagine que vocÃª tem um array de objetos. Cada objeto Ã© um estudante com seu nome, nota e situaÃ§Ã£o no curso. Para ser aprovado, ele precisa obter uma nota acima de 60. Como vocÃª pode ver, o objeto abaixo estÃ¡ desatualizado e precisa ser atualizado: ele nÃ£o contÃ©m a informaÃ§Ã£o acerca da aprovaÃ§Ã£o. Para atualizÃ¡-lo, vocÃª provavelmente escreveria algo assim, utilizando loops:
Copiar
const students = [
  { name: 'Maria', grade: 70, approved: '' },
  { name: 'JosÃ©', grade: 56, approved: '' },
  { name: 'Roberto', grade: 90, approved: '' },
  { name: 'Ana', grade: 81, approved: '' },
];

function verifyGrades() {
  for (let index = 0; index < students.length; index += 1) {
    const student = students[index];
    if (student.grade >= 60) {
      student.approved = 'Aprovado';
    } else {
      student.approved = 'RecuperaÃ§Ã£o';
    }
  }
}

verifyGrades();

console.log(students);
// [
//   { name: 'Maria', grade: 70, approved: 'Aprovado' },
//   { name: 'JosÃ©', grade: 56, approved: 'RecuperaÃ§Ã£o' },
//   { name: 'Roberto', grade: 90, approved: 'Aprovado' },
//   { name: 'Ana', grade: 81, approved: 'Aprovado' }
// ]
Usando forEach, Ã© assim que vocÃª faria a mesma coisa:
Copiar
const students = [
  { name: 'Maria', grade: 70, approved: '' },
  { name: 'JosÃ©', grade: 56, approved: '' },
  { name: 'Roberto', grade: 90, approved: '' },
  { name: 'Ana', grade: 81, approved: '' },
];

function verifyGrades() {
  students.forEach((student, index) => {
    if (student.grade >= 60) {
      students[index].approved = 'Aprovado';
    } else {
      students[index].approved = 'RecuperaÃ§Ã£o';
    }
  });
}

verifyGrades();

console.log(students);
// [
//   { name: 'Maria', grade: 70, approved: 'Aprovado' },
//   { name: 'JosÃ©', grade: 56, approved: 'RecuperaÃ§Ã£o' },
//   { name: 'Roberto', grade: 90, approved: 'Aprovado' },
//   { name: 'Ana', grade: 81, approved: 'Aprovado' }
// ]
Ok, as duas abordagens geram o mesmo resultado, mas qual a diferenÃ§a? Vamos analisar as duas soluÃ§Ãµes e ver em que elas diferem!
Na soluÃ§Ã£o usando for, vocÃª vai precisar se preocupar mais com os detalhes durante a implementaÃ§Ã£o de sua lÃ³gica de execuÃ§Ã£o e menos com a soluÃ§Ã£o do problema que vocÃª deseja solucionar - vocÃª sÃ³ quer atualizar uma propriedade de cada estudante, afinal. VocÃª precisa:
Declarar uma variÃ¡vel para controlar a iteraÃ§Ã£o pelo array;
Inicializar essa variÃ¡vel com zero, a primeira posiÃ§Ã£o do array;
Controlar o ponto de parada, quando o fim do array foi alcanÃ§ado (index < students.length);
Incrementar manualmente a variÃ¡vel de controle do loop a cada iteraÃ§Ã£o (index += 1);
Usar indexaÃ§Ã£o de arrays pra acessar cada elemento/estudante (students[index]);
Ufa! Tudo isso sÃ³ pra atualizar o seu array!
Agora vamos olhar para a segunda soluÃ§Ã£o. Tudo o que vocÃª precisa fazer Ã© chamar a funÃ§Ã£o forEach no array e passar para ela a funÃ§Ã£o que vocÃª criou. E mais nada! Esse Ã© o poder da funÃ§Ã£o forEach. ğŸ˜
Ainda nÃ£o se convenceu? EntÃ£o vamos a mais um exemplo. Queremos encontrar e imprimir no console o primeiro elemento de um array que satisfaÃ§a a uma determinada condiÃ§Ã£o. Pode ser, por exemplo, encontrar o primeiro nÃºmero que seja divisÃ­vel por 5 em uma lista de nÃºmeros.
Primeiro, usando for e if:
Copiar
const numbers = [11, 24, 39, 47, 50, 62, 75, 81, 96, 100];
let firstMultipleOf5;
for (let index = 0; index < numbers.length; index += 1) {
  if (numbers[index] % 5 === 0) {
    firstMultipleOf5 = numbers[index];
    break;
  }
}

console.log(firstMultipleOf5);
// 50
Agora, a mesma coisa usando Array.find:
Copiar
const numbers = [11, 24, 39, 47, 50, 62, 75, 81, 96, 100];
const firstMultipleOf5 = numbers.find((number) => number % 5 === 0);

console.log(firstMultipleOf5);
// 50
AlÃ©m de muito mais concisa, a soluÃ§Ã£o usando find Ã© muito mais fÃ¡cil de entender, concorda?
Ponto de observaÃ§Ã£o: note que o parÃ¢metro passado para numbers.find(), number => number % 5 == 0, Ã© uma arrow function, igual no primeiro exemplo de forEach, em que foi passada a funÃ§Ã£o verifyGrade.
Mas essa ideia de passar uma arrow function para uma funÃ§Ã£o ainda estÃ¡ pouco clara, nÃ£o Ã© mesmo? E esse parÃ¢metro que ela recebe, vem de onde?! Quem passa? Agora vamos ver, em detalhes, a estrutura de uma HOF.



Estrutura das HOFs em Arrays
As Higher Order Functions que veremos hoje sÃ£o parecidas entre si: elas mudam em alguns pontos especÃ­ficos, mas todas possuem a mesma estrutura. Para demonstrar, olhe o exemplo de uma HOF que imprime na tela cada valor do array:
Copiar
const arrayOfValues = ['josÃ©', 50, 0.25, { comida: 'Chocolate' }];
arrayOfValues.forEach((element) => {
  console.log('Cada elemento do array:', element);
});

// Cada elemento do array: josÃ©
// Cada elemento do array: 50
// Cada elemento do array: 0.25
// Cada elemento do array: { comida: 'Chocolate' }
Sua estrutura:
Copiar
arrayOfValues.forEach((element) => {
  console.log('Cada elemento do array:', element);
});
Suas partes:
arrayOfValues - Nome do array que serÃ¡ percorrido;
.forEach - A HOF, pode ser, .find, .some, .every;
element - Valor do elemento do array;
(element) => {console.log('Cada elemento do array:', element); - funÃ§Ã£o a ser executada, pode ser passada igual ao terceiro exemplo do conteÃºdo com a funÃ§Ã£o verifyGrade.
Ã‰ isso mesmo! Quando vocÃª passa uma arrow function para uma HOF, o primeiro parÃ¢metro que essa arrow function recebe Ã© o elemento do array. Em portuguÃªs, Ã© como se:
Copiar
meuArray.forEach((elemento) => {
  if (elemento % 2 === 0) {
    console.log(`${elemento} Ã© divÃ­sivel por 2!`);
  }
});
Significasse Verifique se cada elemento do meu array Ã© mÃºltiplo de 2.
Uma funÃ§Ã£o como meuArray.find(elemento => elemento % 5 === 0), por outro lado, seria Encontre o primeiro elemento de meuArray que Ã© mÃºltiplo de cinco.
Ficou mais claro agora? A prÃ³pria Higher Order Function se encarrega da lÃ³gica de pegar cada elemento do array e passar como parÃ¢metro para a arrow function. Com for vocÃª faria isso manualmente, a proposta aqui Ã© a HOF fazer pra vocÃª! Sua Ãºnica preocupaÃ§Ã£o deve ser "O que eu quero fazer com cada elemento do array?", e nÃ£o "Como eu acesso cada elemento do array?".
Observe abaixo que podemos passar mais de um parÃ¢metro para a funÃ§Ã£o tambÃ©m. As HOFs disponibilizam para vocÃª, caso precisar, acesso a mais informaÃ§Ãµes do array:
Copiar
const arrayOfValues = ['josÃ©', 50, 0.25, { comida: 'Chocolate' }];
arrayOfValues.forEach((element, indexOfTheArray, theEntireArray) => {
  console.log('Cada elemento do array:', element);
  console.log('Index, posiÃ§Ã£o do elemento:', indexOfTheArray);
  console.log('Array percorrido:', theEntireArray);
});

// => ---------------
//   Cada elemento do array: josÃ©
//   Index, posiÃ§Ã£o do elemento: 0
//   Array percorrido: [ 'josÃ©', 50, 0.25, { comida: 'Chocolate' } ]
//   ---------------
//   Cada elemento do array: 50
//   Index, posiÃ§Ã£o do elemento: 1
//   Array percorrido: [ 'josÃ©', 50, 0.25, { comida: 'Chocolate' } ]
//   ---------------
//   Cada elemento do array: 0.25
//   Index, posiÃ§Ã£o do elemento: 2
//   Array percorrido: [ 'josÃ©', 50, 0.25, { comida: 'Chocolate' } ]
//   ---------------
//   Cada elemento do array: { comida: 'Chocolate' }
//   Index, posiÃ§Ã£o do elemento: 3
//   Array percorrido: [ 'josÃ©', 50, 0.25, { comida: 'Chocolate' } ]
A arrow function passada para o forEach possui element, index e array como parÃ¢metros, onde:
element - Valor do elemento do array;
index - Ãndice em cada iteraÃ§Ã£o ou posiÃ§Ã£o do elemento no array, comeÃ§ando do 0;
array - Array original que estÃ¡ sendo percorrido.
Agora que jÃ¡ aprendeu sobre a estrutura, vamos nos aprofundar em cada uma das HOF.



Array.forEach
Como foi visto nos exemplos anteriores, o forEach percorre o array e executa a funÃ§Ã£o passada para cada um dos seus valores. O forEach nÃ£o retorna nenhum valor.
Assista a seguir o vÃ­deo em que o nosso querido Cairo explica como o mÃ©todo forEach funciona.

Agora vamos usar o forEach, para realizar a tabuada do 2. Veja o exemplo abaixo:
Copiar
const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

const multipliesFor2 = (element) => {
  console.log(`${element} * 2: ${element * 2}`);
};

numbers.forEach(multipliesFor2);
No exemplo acima, foi executado para cada elemento do array a funÃ§Ã£o multipliesFor2, que imprime o parÃ¢metro element * 2 no console.
Agora estamos tratando de uma HOF, sendo assim Ã© possÃ­vel se utilizar tambÃ©m dos demais parÃ¢metros para se resolver um problema. Como se pode fazer isso? Veja este exemplo abaixo com o uso de index no forEach:
Copiar
const names = ['Bianca', 'Camila', 'Fernando', 'Ana Roberta'];

const convertToUpperCase = (name, index) => {
  names[index] = name.toUpperCase();
};

names.forEach(convertToUpperCase);
console.log(names); // [ 'BIANCA', 'CAMILA', 'FERNANDO', 'ANA ROBERTA' ]
NÃ£o se esqueÃ§a, tambÃ©m, de rodar todos os exemplos no console do seu navegador ou na sua mÃ¡quina! Isso ajuda muito a fixar as coisas. Brinque e experimente com as funÃ§Ãµes!
Para fixar
1 - Use o mÃ©todo forEach chamando a callback showEmailList para apresentar os emails
Copiar
const emailListInData = [
  'roberta@email.com',
  'paulo@email.com',
  'anaroberta@email.com',
  'fabiano@email.com',
];

const showEmailList = (email) => {
  console.log(`O email ${email} esta cadastrado em nosso banco de dados!`);
};

// Adicione seu cÃ³digo aqui
2 - Leia e entenda este exemplo do forEach feito no CodePen.




Array.find
A funÃ§Ã£o find Ã© utilizada para achar o primeiro elemento que satisfaÃ§a a condiÃ§Ã£o passada. EntÃ£o, a funÃ§Ã£o que deverÃ¡ ser passada precisa retornar true ou false. Nesta pÃ¡gina do MDN vocÃª pode ver com mais detalhes sobre o find. Leia atÃ© a seÃ§Ã£o Exemplos.
A animaÃ§Ã£o abaixo nos mostra como o find pode ser utilizado para encontrar o primeiro item do array listaNumeros maior do que vinte. Essa condiÃ§Ã£o (item > 20) Ã© implementada na funÃ§Ã£o (callback), que serÃ¡ executada para cada elemento de listaNumeros. Quando o primeiro item do array listaNumeros for maior que vinte, a funÃ§Ã£o (callback) retornarÃ¡ true e o find irÃ¡ retornar este elemento que satisfaz a condiÃ§Ã£o passada. Observe que o retorno do mÃ©todo find Ã© um Ãºnico elemento: o primeiro item de listaNUmeros maior do que 20.

GIF ilustrando o mÃ©todo .find()
Olhe o exemplo abaixo:
Copiar
const numbers = [19, 21, 30, 3, 45, 22, 15];

const verifyEven = (number) => number % 2 === 0;

const isEven = numbers.find(verifyEven);

console.log(isEven); // 30

console.log(verifyEven(9)); // False
console.log(verifyEven(14)); // True

// Outra forma de ser realizada sem a necessidade de criar uma nova funÃ§Ã£o.
const isEven2 = numbers.find((number) => number % 2 === 0);

console.log(isEven2); // 30
Esse exemplo mostra duas formas de resolver o mesmo problema, que Ã© retornar o primeiro nÃºmero par do array.
Primeiro observe a funÃ§Ã£o verifyEven. Ela verifica se o nÃºmero recebido Ã© par. Se sim, seu retorno serÃ¡ true; caso contrÃ¡rio, seu retorno Ã© false.
Quando a passamos como callback, o find executarÃ¡ a funÃ§Ã£o para cada um dos elementos do array e retornarÃ¡ o primeiro elemento quando o retorno da funÃ§Ã£o for true.
Para fixar
1 - Utilize o find para retornar o primeiro nÃºmero do array que Ã© divisÃ­vel por 3 e 5, caso ele exista:
Copiar
const numbers = [19, 21, 30, 3, 45, 22, 15];

const findDivisibleBy3And5 = () => {
  // Adiciona seu cÃ³digo aqui
}

console.log(findDivisibleBy3And5())
2 - Utilize o find para encontrar o primeiro nome com cinco letras, caso ele exista:
Copiar
const names = ['JoÃ£o', 'Irene', 'Fernando', 'Maria'];

const findNameWithFiveLetters = () => {
  // Adicione seu cÃ³digo aqui:
}

console.log(findNameWithFiveLetters());
3 - Utilize o find para encontrar a mÃºsica com id igual a 31031685, caso ela exista:
Copiar
const musicas = [
  { id: '31031685', title: 'Partita in C moll BWV 997' },
  { id: '31031686', title: 'Toccata and Fugue, BWV 565' },
  { id: '31031687', title: 'Chaconne, Partita No. 2 BWV 1004' },
]

function findMusic(id) {
  // Adicione seu cÃ³digo aqui
}

console.log(findMusic('31031685'))




Array.some e Array.every
As funÃ§Ãµes some e every sÃ£o parecidas. A primeira retorna true se ao menos um elemento de um array satisfaz a uma condiÃ§Ã£o. A segunda retorna true se todos os elementos de um array satisfazem a uma condiÃ§Ã£o. O MDN contÃ©m explicaÃ§Ãµes mais detalhadas sobre essas funÃ§Ãµes, alÃ©m de exemplos. Clique aqui e aqui para ler sobre essas funÃ§Ãµes. Leia atÃ© a seÃ§Ã£o Exemplos.
Para visualizar melhor o retorno dos mÃ©todos some e every, brinque com esses dois exemplos no CodePen nos links abaixo. VocÃª pode alterar os nÃºmeros do array numbers para verificar o que a funÃ§Ã£o estÃ¡ retornando para cada caso.
Array.some: link
Array.every: link
O exemplo abaixo usa o some para verificar se possui algum nome que comeÃ§a com a letra desejada:
Copiar
const listNames = ['Maria', 'Manuela', 'Jorge', 'Ricardo', 'Wilson'];

const verifyFirstLetter = (letter, names) => names.some((name) => name[0] === letter);

console.log(verifyFirstLetter('J', listNames)); // true
console.log(verifyFirstLetter('x', listNames)); // false
O exemplo abaixo usarÃ¡ o every para verificar se o estudante passou em todas as matÃ©rias:
Copiar
const grades = {
  portugues: 'Aprovado',
  matematica: 'Reprovado',
  ingles: 'Aprovado',
};

const verifyGrades = (studentGrades) => (
  Object.values(studentGrades).every((grade) => grade === 'Aprovado')
);

console.log(verifyGrades(grades));
Observe que foi usado Object.values junto com o every. Como o Object.values retorna um array apenas com os valores do objeto, o every percorrerÃ¡ esse array retornado. Interessante essa combinaÃ§Ã£o de funÃ§Ãµes, hein?! Experimente alguma combinaÃ§Ã£o dessas na sua prÃ³pria mÃ¡quina agora!
Para fixar
1 - Escreva uma funÃ§Ã£o que recebe dois parÃ¢metros: o primeiro um array de nomes e o segundo, um nome qualquer. Essa funÃ§Ã£o deve retornar true se o segundo parÃ¢metro - um nome qualquer - estiver contido no primeiro parÃ¢metro - array de nomes. Caso nÃ£o esteja contido, deve retornar false.
Dica: use some.
Copiar
const names = ['Mateus', 'JosÃ©', 'Ana', 'ClÃ¡udia', 'Bruna'];

const hasName = (arr, name) => {
  //Adicione seu cÃ³digo aqui
}

console.log(hasName(names, 'Ana'))
2 - Escreva uma funÃ§Ã£o que dado um array de pessoas e uma idade mÃ­nima retorne true se todas tiverem a idade maior ou igual a mÃ­nima e caso contrÃ¡rio false, use every;
Copiar
const people = [
  { name: 'Mateus', age: 18 },
  { name: 'JosÃ©', age: 16 },
  { name: 'Ana', age: 23 },
  { name: 'ClÃ¡udia', age: 20 },
  { name: 'Bruna', age: 19 },
];

const verifyAges = (arr, minimumAge) => {
  //Adicione seu cÃ³digo aqui
}

console.log(verifyAges(people, 18));



Array.sort
Por Ãºltimo, existe a funÃ§Ã£o sort. Ela permite ordenar um array de acordo com algum critÃ©rio estabelecido. Veja este exemplo com um array de strings:
Copiar
const food = ['arroz', 'feijÃ£o', 'farofa', 'chocolate', 'doce de leite'];
food.sort();
console.log(food);
// [ 'arroz', 'chocolate', 'doce de leite', 'farofa', 'feijÃ£o' ]
Funcionou bem com um array de strings, nÃ£o Ã© mesmo? Por tanto, caso queira ordenar de forma alfabÃ©tica, basta chamar sort, sem parÃ¢metros algum na funÃ§Ã£o. Agora, veja este exemplo com um array de nÃºmeros:
Copiar
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
numbers.sort();
console.log(numbers); // [1, 10, 2, 3, 4, 5, 6, 7, 8, 9]
ğŸ˜® O que aconteceu com esta ordenaÃ§Ã£o?
Como pode notar, a forma como ela organiza os elementos do array nÃ£o Ã© tÃ£o intuitiva. Isso ocorre, pois ela distribui sempre por ordem alfabÃ©tica. No caso, quando hÃ¡ elementos como nÃºmeros, a sort coloca de acordo com a ordem alfabÃ©tica dos cÃ³digos desse elemento na tabela de caracteres unicode!
Agora, se deseja ordenar de forma numÃ©rica crescente, Ã© necessÃ¡rio passar a funÃ§Ã£o a seguir:
Copiar
const points = [40, 100, 1, 5, 25, 10];
points.sort((a, b) => a - b);
console.log(points); // [1, 5, 10, 25, 40, 100]
A lÃ³gica Ã© a seguinte: a funÃ§Ã£o recebe, da sort, todos os elementos do array, em pares (elemento1, elemento2), e vai comparando-os. O formato Ã© meuArray.sort((elemento1, elemento2) => /* logica da funÃ§Ã£o */). Ou seja: para o array [1, 2, 3, 4], a funÃ§Ã£o receberÃ¡ (2, 1), (3, 2), (4, 3) como parÃ¢metros e ordenarÃ¡ o array com base em seu resultado. Se a operaÃ§Ã£o de elemento1 com elemento2 der resultado negativo, elemento1 vai para trÃ¡s. Caso contrÃ¡rio, vai para frente, para, de forma decrescente, sÃ³ inverter elemento1 - elemento2 para elemento2 - elemento1. Novamente, o artigo do MDN Ã© uma excelente fonte de informaÃ§Ã£o para entender melhor.
Veja agora se realizarmos uma simples modificaÃ§Ã£o no retorno da funÃ§Ã£o que ordena os nÃºmeros e veja o que acontece:
Copiar
const points = [40, 100, 1, 5, 25, 10];
points.sort((a, b) => b - a);
console.log(points); // [ 100, 40, 25, 10, 5, 1 ]
Assista ao vÃ­deo abaixo sobre o mÃ©todo sort().

VocÃª sabia que o sort() tambÃ©m pode ser utilizado em um array de objetos? O vÃ­deo abaixo te mostra como ğŸ‘‡

Para visualizar como o sort funciona, brinque com este exemplo feito no CodePen.
Para fixar
1 - Utilize sort para ordenar o array pela idade das pessoas em ordem crescente.
Copiar
const people = [
  { name: 'Mateus', age: 18 },
  { name: 'JosÃ©', age: 16 },
  { name: 'Ana', age: 23 },
  { name: 'ClÃ¡udia', age: 20 },
  { name: 'Bruna', age: 19 },
];

// Adicione se cÃ³digo aqui

console.log(people);
2 - Modifique o sort do exercÃ­cio anterior para que ordene o array pela idade das pessoas em ordem decrescente.



Vamos praticar!
Ã‰ hora de colocar em prÃ¡tica todo esse conhecimento. ğŸ’ª
Aula ao vivo! Vamos para o Slack, onde o link estarÃ¡ disponÃ­vel.



InstruÃ§Ãµes para realizaÃ§Ã£o dos exercÃ­cios
Nos exercÃ­cios a seguir, vocÃª trabalharÃ¡ com uma estrutura de dados representando uma lista de livros, contendo informaÃ§Ãµes como nome do livro, gÃªnero, pessoa autora do livro e data de lanÃ§amento.
Em cada exercÃ­cio, serÃ¡ pedido que vocÃª encontre ou produza alguma informaÃ§Ã£o a respeito dessa lista utilizando as funÃ§Ãµes que vocÃª aprendeu hoje. Todos os exercÃ­cios contÃªm um cÃ³digo base. VocÃª deverÃ¡ copiar esse cÃ³digo e salvÃ¡-lo em um arquivo nomeado conforme o nÃºmero do exercÃ­cio, completando a funÃ§Ã£o em branco.
Por exemplo, o exercÃ­cio 1 deve ser salvo no arquivo exercise1.js, e assim por diante.
ğŸš€ Se liga nesse foguete!
Os exercÃ­cios destacados com ğŸš€ sÃ£o os fundamentais pra vocÃª ir bem no projeto! Todos os exercÃ­cios vÃ£o contribuir com sua formaÃ§Ã£o mas fique de olho nesses! ğŸ‘€



