O que vamos aprender?
Hoje voc√™ vai aprender sobre outra Higher Order Functions: Array.reduce
Essa fun√ß√£o √©, talvez, uma das mais poderosas fun√ß√µes para manipula√ß√£o e cria√ß√£o de arrays. Ela deixar√° seu c√≥digo mais leg√≠vel, conciso e expressivo.



Voc√™ ser√° capaz de:
Utilizar a fun√ß√£o Array.reduce para manipular e construir arrays;



Por que isso √© importante?
Como j√° viu na primeira parte, as HOFs ajudam bastante a reduzir o c√≥digo e deix√°-lo mais compreens√≠vel. A HOF de hoje √© um pouco mais desafiadora, mas voc√™ usar√° ela bastante no seu c√≥digo daqui pra frente e logo estar√° tirando-a de letra!



Array.reduce
O reduce √© diferente das outras HOFs: ele recebe dois par√¢metros sendo o primeiro uma callback e o segundo um valor inicial, que √© opcional. Como o pr√≥prio nome diz o reduce busca reduzir um array. Isto √©, iterando em elementos de um array, ao final ele gera um valor √∫nico de qualquer tipo, como, por exemplo, a soma de todos os elementos de tal array. Como principais vantagens do uso do m√©todo reduce podemos destacar:
escrita de c√≥digo mais limpo;
maior facilidade ao implementar a l√≥gica com a qual se quer trabalhar;
melhor manuten√ß√£o de c√≥digo. Veja abaixo a estrutura completa do reduce:
Copiar

reduce((accumulator, currentValue, currentIndex, array) => { /* ... */ }, initialValue )
A callback, que √© o primeiro par√¢metro do reduce, tamb√©m pode receber at√© quatro par√¢metros. Desses quatro par√¢metros apenas dois deles devem existir obrigatoriamente, sendo eles o acc e o curr. Temos ent√£o que acc abreviatura de accumulator ou acumulador, deve obrigatoriamente ser o primeiro par√¢metro da callback e o curr, abreviatura de currentValue ou valor atual tamb√©m obrigat√≥rio, deve ser o segundo par√¢metro da callback. Sendo assim, para trabalhar com uma fun√ß√£o de reduce voc√™ deve ter algo parecido com o c√≥digo abaixo:
Copiar

array.reduce((acc, curr) => {
      // escopo de execu√ß√£o da fun√ß√£o
}, valorInicial)
Lembrando que initialValue ou valorInicial n√£o √© um par√¢metro obrigat√≥rio do reduce e que a callback pode receber at√© quatro par√¢metros, mas aqui vamos abordar os obrigat√≥rios, o acc e o curr.
O que ent√£o faz o acumulador ou acc? A fun√ß√£o do acumulador √© guardar o retorno da callback, a cada itera√ß√£o, tendo como ponto de partida o valorInicial quando estabelecido. Quando n√£o estabelecido, automaticamente o acc assume o valor do primeiro elemento do array que est√° iterando. Confira o c√≥digo abaixo onde vamos calcular a soma total dos elementos de um array:
Copiar

const numbers = [1, 32, 44, 2, 3];
const iteracoesDoReduce = numbers.reduce((acc, curr) => {
  console.log(`valor atual √© ${curr}`);
  // Antes da primeira itera√ß√£o o valor de in√≠cio do `acc` √© o valor no index 0 do array, e o valor de in√≠cio de `curr` √© o valor no index 1 do array.
      // Itera√ß√£o 1: valor do acc √© 1 e o de curr √© 32;
 // Ap√≥s a primeira itera√ß√£o, o valor de `acc` muda e passa a acumular agora o resultado do retorno da callback (acc + curr).
     // Itera√ß√£o 2: valor do acc √© 33 e o de curr √© 44;
// Acontece ent√£o uma segunda itera√ß√£o, e `curr` agora assume o valor do index na sequ√™ncia do array, no caso o valor do segundo index e `acc` segue armazenando os retornos.
    // Itera√ß√£o 3: valor do acc √© 77 e o de curr √© 2;
    // Itera√ß√£o 4: valor do acc √© 79 e o de curr √© 3;
    // Valor final de `acc`√© 82 e `curr` para no 3.
  
  
  return acc +  curr // Ao fim das itera√ß√µes podemos ver que o `acc` armazenou o resultado total do retorno da fun√ß√£o.
  
});

console.log(`O resultado final √© ${iteracoesDoReduce}`);
  // por fim, esse console.log imprime o retorno final da nossa fun√ß√£o, 
Ao observar o c√≥digo acima identificamos tamb√©m o papel do curr, que sempre armazena o valor do elemento atual, ou seja, o elemento do array que est√° sendo iterado no momento.
Passando um valor para o acc
Confuso ü§î? Vamos a outro exemplo! Imagine que novamente voc√™ queira somar todos os valores de um array. Mas agora teremos um valor inicial j√° estipulado para o acc. Antes de conhecer o reduce, voc√™ faria algo parecido com o c√≥digo abaixo, correto?
Copiar
const numbers = [1, 32, 44, 2, 3];
let sumNumbers = 30;
// A vari√°vel `sumNumbers` tem um valor inicial de 30 e vai acumulando, a cada itera√ß√£o do for, o resultado da opera√ß√£o feita em seu escopo!

for (let index = 0; index < numbers.length; index += 1) {
  sumNumbers += numbers[index];
}
console.log(sumNumbers); // 112
Veja o mesmo feito com reduce:
Copiar
const numbers = [1, 32, 44, 2, 3];

const totalSum = numbers.reduce((acc, curr) => {
  console.log(`valor do acc √© ${acc} e o de curr √© ${curr}`);
   // Itera√ß√£o 1: valor do acc √© 30 e o de curr √© 1
   // Itera√ß√£o 2:valor do acc √© 31 e o de curr √© 32
   // Itera√ß√£o 3: valor do acc √© 63 e o de curr √© 44
   // Itera√ß√£o 4: valor do acc √© 107 e o de curr √© 2
   // Itera√ß√£o 5: valor do acc √© 107 e o de curr √© 3
   // Valor final de `acc`√© 112 e `curr` para no 3


  return acc + curr;
}, 30); // O `valorInicial` √© 30, ou seja, `acc` antes de executar a primeira itera√ß√£o j√° est√° armazenando esse valor.

console.log(`valor final do acc √© ${totalSum}`);
  // por fim, esse `console.log` imprime o retorno da nossa fun√ß√£o, que √© o valor final de `acc` ap√≥s cada uma das 5 itera√ß√µes, tendo iniciado com valor 30.
Pode parecer estranho definir um valor fixo para o acumulador, mas isso porque estamos trabalhando com n√∫meros. O reduce √© uma ferramenta poderosa e em um c√≥digo mais complexo ele poderia receber um valor din√¢mico, atrav√©s de uma vari√°vel ou at√© mesmo qualquer valor que n√£o seja um n√∫mero. Vale lembrar tamb√©m que voc√™ aprendeu a usar o reduce com seus dois primeiros par√¢metros, mas embora pouco utilizados, existem mais dois par√¢metros opcionais: index e array. Veja exemplos utilizando todos os quatro par√¢metros do reduce acessando sua documenta√ß√£o.
Dissecando as fun√ß√µes
Basicamente o reduce funciona como o funil no gif abaixo:

GIF ilustrando o m√©todo .reduce()
E na pr√°tica, qual a vantagem de se usar o reduce ü§î? Vamos dissecar a diferen√ßa ao usar o for e ao usar o reduce:
M√©todo for:
Necessidade de criar uma vari√°vel para acumular o resultado de cada itera√ß√£o do for, a soma de cada resultado - let sumNumbers;
Necessidade de setar um valor inicial para vari√°vel - sumNumbers = 30;
M√©todo .reduce:
A fun√ß√£o callback passada por par√¢metro recebe dois par√¢metros, o acumulador acc e o elemento do array de cada itera√ß√£o, curr;
Como a fun√ß√£o √© uma arrow function que possui apenas uma linha, o retorno de cada itera√ß√£o ser√°: acc + curr;
O retorno √© salvo no primeiro par√¢metro , acc. √â como se voc√™ estivesse fazendo igual √† primeira fun√ß√£o, sumNumbers = sumNumbers + numbers[index], mas nesse caso seria acc = acc + curr;
Organizando para simplificar
Veja tamb√©m que ao inv√©s de passar a l√≥gica direto dentro da callback do reduce, voc√™ pode criar uma fun√ß√£o externa e cham√°-la como sendo o par√¢metro callback:
Copiar
const numbers = [1, 32, 44, 2, 3];

const sumNumbers =  (acc, curr) => acc + curr;

const totalSum = numbers.reduce(sumNumbers, 30);

console.log(totalSum); //112
Dessa maneira seu c√≥digo fica mais organizado e voc√™ poder√° reutilizar a fun√ß√£o sumNumbers caso seja necess√°rio.
‚úçÔ∏è Anote a dica: acc e curr s√£o apenas nomes costumeiros, voc√™ pode dar o nome que quiser para o seu c√≥digo, sendo uma boa op√ß√£o escolher nomes sem√¢nticos, de acordo com o que √© executado pela fun√ß√£o em quest√£o.



Array.reduce
O reduce √© diferente das outras HOFs: ele recebe dois par√¢metros sendo o primeiro uma callback e o segundo um valor inicial, que √© opcional. Como o pr√≥prio nome diz o reduce busca reduzir um array. Isto √©, iterando em elementos de um array, ao final ele gera um valor √∫nico de qualquer tipo, como, por exemplo, a soma de todos os elementos de tal array. Como principais vantagens do uso do m√©todo reduce podemos destacar:
escrita de c√≥digo mais limpo;
maior facilidade ao implementar a l√≥gica com a qual se quer trabalhar;
melhor manuten√ß√£o de c√≥digo. Veja abaixo a estrutura completa do reduce:
Copiar

reduce((accumulator, currentValue, currentIndex, array) => { /* ... */ }, initialValue )
A callback, que √© o primeiro par√¢metro do reduce, tamb√©m pode receber at√© quatro par√¢metros. Desses quatro par√¢metros apenas dois deles devem existir obrigatoriamente, sendo eles o acc e o curr. Temos ent√£o que acc abreviatura de accumulator ou acumulador, deve obrigatoriamente ser o primeiro par√¢metro da callback e o curr, abreviatura de currentValue ou valor atual tamb√©m obrigat√≥rio, deve ser o segundo par√¢metro da callback. Sendo assim, para trabalhar com uma fun√ß√£o de reduce voc√™ deve ter algo parecido com o c√≥digo abaixo:
Copiar

array.reduce((acc, curr) => {
      // escopo de execu√ß√£o da fun√ß√£o
}, valorInicial)
Lembrando que initialValue ou valorInicial n√£o √© um par√¢metro obrigat√≥rio do reduce e que a callback pode receber at√© quatro par√¢metros, mas aqui vamos abordar os obrigat√≥rios, o acc e o curr.
O que ent√£o faz o acumulador ou acc? A fun√ß√£o do acumulador √© guardar o retorno da callback, a cada itera√ß√£o, tendo como ponto de partida o valorInicial quando estabelecido. Quando n√£o estabelecido, automaticamente o acc assume o valor do primeiro elemento do array que est√° iterando. Confira o c√≥digo abaixo onde vamos calcular a soma total dos elementos de um array:
Copiar

const numbers = [1, 32, 44, 2, 3];
const iteracoesDoReduce = numbers.reduce((acc, curr) => {
  console.log(`valor atual √© ${curr}`);
  // Antes da primeira itera√ß√£o o valor de in√≠cio do `acc` √© o valor no index 0 do array, e o valor de in√≠cio de `curr` √© o valor no index 1 do array.
      // Itera√ß√£o 1: valor do acc √© 1 e o de curr √© 32;
 // Ap√≥s a primeira itera√ß√£o, o valor de `acc` muda e passa a acumular agora o resultado do retorno da callback (acc + curr).
     // Itera√ß√£o 2: valor do acc √© 33 e o de curr √© 44;
// Acontece ent√£o uma segunda itera√ß√£o, e `curr` agora assume o valor do index na sequ√™ncia do array, no caso o valor do segundo index e `acc` segue armazenando os retornos.
    // Itera√ß√£o 3: valor do acc √© 77 e o de curr √© 2;
    // Itera√ß√£o 4: valor do acc √© 79 e o de curr √© 3;
    // Valor final de `acc`√© 82 e `curr` para no 3.
  
  
  return acc +  curr // Ao fim das itera√ß√µes podemos ver que o `acc` armazenou o resultado total do retorno da fun√ß√£o.
  
});

console.log(`O resultado final √© ${iteracoesDoReduce}`);
  // por fim, esse console.log imprime o retorno final da nossa fun√ß√£o, 
Ao observar o c√≥digo acima identificamos tamb√©m o papel do curr, que sempre armazena o valor do elemento atual, ou seja, o elemento do array que est√° sendo iterado no momento.
Passando um valor para o acc
Confuso ü§î? Vamos a outro exemplo! Imagine que novamente voc√™ queira somar todos os valores de um array. Mas agora teremos um valor inicial j√° estipulado para o acc. Antes de conhecer o reduce, voc√™ faria algo parecido com o c√≥digo abaixo, correto?
Copiar
const numbers = [1, 32, 44, 2, 3];
let sumNumbers = 30;
// A vari√°vel `sumNumbers` tem um valor inicial de 30 e vai acumulando, a cada itera√ß√£o do for, o resultado da opera√ß√£o feita em seu escopo!

for (let index = 0; index < numbers.length; index += 1) {
  sumNumbers += numbers[index];
}
console.log(sumNumbers); // 112
Veja o mesmo feito com reduce:
Copiar
const numbers = [1, 32, 44, 2, 3];

const totalSum = numbers.reduce((acc, curr) => {
  console.log(`valor do acc √© ${acc} e o de curr √© ${curr}`);
   // Itera√ß√£o 1: valor do acc √© 30 e o de curr √© 1
   // Itera√ß√£o 2:valor do acc √© 31 e o de curr √© 32
   // Itera√ß√£o 3: valor do acc √© 63 e o de curr √© 44
   // Itera√ß√£o 4: valor do acc √© 107 e o de curr √© 2
   // Itera√ß√£o 5: valor do acc √© 107 e o de curr √© 3
   // Valor final de `acc`√© 112 e `curr` para no 3


  return acc + curr;
}, 30); // O `valorInicial` √© 30, ou seja, `acc` antes de executar a primeira itera√ß√£o j√° est√° armazenando esse valor.

console.log(`valor final do acc √© ${totalSum}`);
  // por fim, esse `console.log` imprime o retorno da nossa fun√ß√£o, que √© o valor final de `acc` ap√≥s cada uma das 5 itera√ß√µes, tendo iniciado com valor 30.
Pode parecer estranho definir um valor fixo para o acumulador, mas isso porque estamos trabalhando com n√∫meros. O reduce √© uma ferramenta poderosa e em um c√≥digo mais complexo ele poderia receber um valor din√¢mico, atrav√©s de uma vari√°vel ou at√© mesmo qualquer valor que n√£o seja um n√∫mero. Vale lembrar tamb√©m que voc√™ aprendeu a usar o reduce com seus dois primeiros par√¢metros, mas embora pouco utilizados, existem mais dois par√¢metros opcionais: index e array. Veja exemplos utilizando todos os quatro par√¢metros do reduce acessando sua documenta√ß√£o.
Dissecando as fun√ß√µes
Basicamente o reduce funciona como o funil no gif abaixo:

GIF ilustrando o m√©todo .reduce()
E na pr√°tica, qual a vantagem de se usar o reduce ü§î? Vamos dissecar a diferen√ßa ao usar o for e ao usar o reduce:
M√©todo for:
Necessidade de criar uma vari√°vel para acumular o resultado de cada itera√ß√£o do for, a soma de cada resultado - let sumNumbers;
Necessidade de setar um valor inicial para vari√°vel - sumNumbers = 30;
M√©todo .reduce:
A fun√ß√£o callback passada por par√¢metro recebe dois par√¢metros, o acumulador acc e o elemento do array de cada itera√ß√£o, curr;
Como a fun√ß√£o √© uma arrow function que possui apenas uma linha, o retorno de cada itera√ß√£o ser√°: acc + curr;
O retorno √© salvo no primeiro par√¢metro , acc. √â como se voc√™ estivesse fazendo igual √† primeira fun√ß√£o, sumNumbers = sumNumbers + numbers[index], mas nesse caso seria acc = acc + curr;
Organizando para simplificar
Veja tamb√©m que ao inv√©s de passar a l√≥gica direto dentro da callback do reduce, voc√™ pode criar uma fun√ß√£o externa e cham√°-la como sendo o par√¢metro callback:
Copiar
const numbers = [1, 32, 44, 2, 3];

const sumNumbers =  (acc, curr) => acc + curr;

const totalSum = numbers.reduce(sumNumbers, 30);

console.log(totalSum); //112
Dessa maneira seu c√≥digo fica mais organizado e voc√™ poder√° reutilizar a fun√ß√£o sumNumbers caso seja necess√°rio.
‚úçÔ∏è Anote a dica: acc e curr s√£o apenas nomes costumeiros, voc√™ pode dar o nome que quiser para o seu c√≥digo, sendo uma boa op√ß√£o escolher nomes sem√¢nticos, de acordo com o que √© executado pela fun√ß√£o em quest√£o.



Vamos praticar!
√â hora de colocar em pr√°tica todo esse conhecimento. üí™ Vamos ver alguns exemplos de como aplicar o reduce.
Aula ao vivo! Vamos para o Slack onde o link estar√° dispon√≠vel.



Instru√ß√µes para realiza√ß√£o dos exerc√≠cios
Nos exerc√≠cios a seguir, voc√™ trabalhar√° com uma estrutura de dados representando uma lista de livros, contendo informa√ß√µes como nome do livro, g√™nero, pessoa autora do livro e data de lan√ßamento.
Em cada exerc√≠cio, ser√° pedido que voc√™ encontre ou produza alguma informa√ß√£o a respeito dessa lista utilizando as fun√ß√µes que voc√™ aprendeu hoje. Todos os exerc√≠cios cont√™m um c√≥digo base. Voc√™ dever√° copiar esse c√≥digo e salv√°-lo em um arquivo nomeado conforme o n√∫mero do exerc√≠cio, completando a fun√ß√£o em branco.
Por exemplo, o exerc√≠cio 1 deve ser salvo no arquivo exercise1.js, e assim por diante.
üöÄ Se liga nesse foguete!
Os exerc√≠cios destacados com üöÄ s√£o os fundamentais pra voc√™ ir bem no projeto! Todos os exerc√≠cios v√£o contribuir com sua forma√ß√£o mas fique de olho nesses! üëÄ



Agora a pr√°tica
Todos os exerc√≠cios devem ser realizados utilizando reduce, e se necess√°rio outra HOF, a informa√ß√£o ser√° citada no enunciado.
1 - Dada uma matriz, transforme em um array.
Copiar
const arrays = [
  ['1', '2', '3'],
  [true],
  [4, 5, 6],
];

function flatten() {
  // escreva seu c√≥digo aqui
}
Para os exerc√≠cios 2, 3 e 4 considere o seguinte array:
Copiar
const books = [
  {
    id: 1,
    name: 'As Cr√¥nicas de Gelo e Fogo',
    genre: 'Fantasia',
    author: {
      name: 'George R. R. Martin',
      birthYear: 1948,
    },
    releaseYear: 1991,
  },
  {
    id: 2,
    name: 'O Senhor dos An√©is',
    genre: 'Fantasia',
    author: {
      name: 'J. R. R. Tolkien',
      birthYear: 1892,
    },
    releaseYear: 1954,
  },
  {
    id: 3,
    name: 'Funda√ß√£o',
    genre: 'Fic√ß√£o Cient√≠fica',
    author: {
      name: 'Isaac Asimov',
      birthYear: 1920,
    },
    releaseYear: 1951,
  },
  {
    id: 4,
    name: 'Duna',
    genre: 'Fic√ß√£o Cient√≠fica',
    author: {
      name: 'Frank Herbert',
      birthYear: 1920,
    },
    releaseYear: 1965,
  },
  {
    id: 5,
    name: 'A Coisa',
    genre: 'Terror',
    author: {
      name: 'Stephen King',
      birthYear: 1947,
    },
    releaseYear: 1986,
  },
  {
    id: 6,
    name: 'O Chamado de Cthulhu',
    genre: 'Terror',
    author: {
      name: 'H. P. Lovecraft',
      birthYear: 1890,
    },
    releaseYear: 1928,
  },
];

// Adicione o c√≥digo do exerc√≠cio aqui:
2 - Crie uma string com os nomes de todas as pessoas autoras.
Copiar
const expectedResult = "George R. R. Martin, J. R. R. Tolkien, Isaac Asimov, Frank Herbert, Stephen King, H. P. Lovecraft.";

function reduceNames() {
  // escreva seu c√≥digo aqui
}
üöÄ 3- Calcule a m√©dia de idade que as pessoas autoras tinham quando seus respectivos livros foram lan√ßados.
Copiar
const expectedResult = 43;

function averageAge() {
  // escreva seu c√≥digo aqui
}
üöÄ 4- Encontre o livro com o maior nome.
Copiar

const expectedResult = {
  id: 1,
  name: 'As Cr√¥nicas de Gelo e Fogo',
  genre: 'Fantasia',
  author: {
    name: 'George R. R. Martin',
    birthYear: 1948,
  },
  releaseYear: 1991,
};

function longestNamedBook() {
  // escreva seu c√≥digo aqui
}
üöÄ 5- Dada o array de nomes, retorne a quantidade de vezes em que aparecem a letra a mai√∫scula ou min√∫scula.
Copiar
const names = [
  'Aanemarie', 'Adervandes', 'Akifusa',
  'Abegildo', 'Adicellia', 'Aladonata',
  'Abeladerco', 'Adieidy', 'Alarucha',
];

function containsA() {
  // escreva seu c√≥digo aqui
}
üöÄ 6- Para o pr√≥ximo exerc√≠cio voc√™ deve criar um novo array de objetos a partir das informa√ß√µes das constantes students e grades, onde cada objeto desse novo array ter√° o formato { name: nome do aluno, average: media das notas }. Para isso vamos assumir que a posi√ß√£o do index 0 de grades refere-se ao estudante na posi√ß√£o de index 0 de students. Para resolver este exerc√≠cio, al√©m de reduce, ser√° necess√°rio utilizar tamb√©m a fun√ß√£o map. Dica: Voc√™ pode acessar o index do array dentro de map, e voc√™ pode ver o objeto esperado na constante expected.
Copiar
const students = ['Pedro Henrique', 'Miguel', 'Maria Clara'];
const grades = [[9, 8, 10, 7, 5], [10, 9, 9, 10, 8], [10, 7, 10, 8, 9]];

function studentAverage() {
  // escreva seu c√≥digo aqui
}

const expected = [
  { name: 'Pedro Henrique', average: 7.8 },
  { name: 'Miguel', average: 9.2 },
  { name: 'Maria Clara', average: 8.8 },
];


