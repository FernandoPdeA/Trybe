O que vamos aprender?
Hoje voc√™ vai aprender sobre algoritmos e l√≥gica de programa√ß√£o, a base de tudo que faremos daqui pra frente.
Assim como em uma receita de bolo, na programa√ß√£o, devemos passo a passo utilizar comandos para resolver um problema. Essa sequ√™ncia de comandos se chama algoritmo. Para criar um algoritmo, temos que desenvolver uma capacidade anal√≠tica para transformar grandes problemas em pequenos e encadeados comandos l√≥gicos. Desenvolvemos essa forma de raciocinar com a l√≥gica de programa√ß√£o.




Voc√™ ser√° capaz de:
Quebrar grandes problemas em pequenos;
Utilizar a l√≥gica de programa√ß√£o na resolu√ß√£o de problemas.



L√≥gica de Programa√ß√£o
A l√≥gica de programa√ß√£o consiste em uma s√©rie de regras e normas baseadas na l√≥gica matem√°tica e em teorias da computa√ß√£o, que tem como objetivo facilitar o racioc√≠nio no momento da cria√ß√£o de uma cadeia de comandos.
Antes de adentrar os requisitos mais t√©cnicos, tenha em mente que aprender a teoria sobre esse assunto n√£o √© suficiente. O processo de utiliza√ß√£o da l√≥gica de programa√ß√£o demanda tempo e repeti√ß√£o, at√© que se torne autom√°tico. Voc√™ desenvolver√° essa habilidade aos poucos ao longo de todo o curso!
Outro ponto importante √© que a l√≥gica de programa√ß√£o n√£o se restringe a uma linguagem espec√≠fica. Voc√™ ir√° aprender a partir de JavaScript, mas a l√≥gica √© aplic√°vel a todas as outras linguagens. Por isso costuma-se dizer que, a cada linguagem que aprendemos, fica mais f√°cil aprender a pr√≥xima, pois j√° exercitamos nosso racioc√≠nio e temos apenas que adaptar nossos algoritmos, que veremos mais a frente, √†s particularidades de determinada linguagem.
Assista esse v√≠deo para entender os conceitos da l√≥gica:




Algoritmos
O algoritmo √© uma s√©rie de comandos encadeados de forma l√≥gica, que busca resolver algum problema.
Utilizamos l√≥gica em muitos momentos do nosso dia a dia de forma autom√°tica. Pense no leite com achocolatado que voc√™ toma pela manh√£. Simples faz√™-lo, n√£o? Vejamos o passo a passo:
Copiar
1. Pegar um copo
2. Colocar o copo em cima da mesa
3. Abrir a porta da geladeira
4. Pegar o leite
5. Fechar a porta da geladeira
6. Colocar determinada quantidade de leite no copo
7. Abrir o arm√°rio
8. Pegar o achocolatado
9. Fechar a porta do arm√°rio
10. Colocar determinada quantidade de achocolatado no copo
11. Pegar uma colher
12. Mexer no copo com a colher
Imagine se tiv√©ssemos que pensar em todo esse passo a passo toda manh√£. Felizmente, j√° conseguimos interpretar essa s√©rie de instru√ß√µes de forma l√≥gica e autom√°tica.
Os computadores n√£o tem esse poder. Para o bem ou para o mal, computadores s√£o isentos de vieses e interpreta√ß√µes. Por isso, cada comando deve ser cirurgicamente determinado. Caso, no passo 4, estivesse escrito "Pegar o lete", o que seria pra n√≥s um simples erro ortogr√°fico, mas que n√£o traria danos √† execu√ß√£o do processo, para o computador seria um erro de sintaxe, que inviabilizaria o funcionamento do algoritmo. Provavelmente um erro como lete is not defined seria retornado.
Por√©m, algumas ordens poderiam ser trocadas sem preju√≠zo na execu√ß√£o. Por exemplo, poder√≠amos utilizar os passos 7, 8, 9 e 10 antes dos 3, 4, 5 e 6. Ou seja, colocar o achocolatado no copo antes do leite. Esse tipo de decis√£o √© comum na vida das pessoas desenvolvedoras.
Quando nos deparamos com problemas, devemos raciocinar e enxergar quais os caminhos poss√≠veis para a sua resolu√ß√£o. Muitas vezes esses caminhos s√£o m√∫ltiplos, o que nos leva a decidir qual percorrer. Alguns fatores como performance, propriedades da linguagem utilizada, legibilidade do c√≥digo e tempo devem ser levados em considera√ß√£o no momento da decis√£o. No exemplo do leite com achocolatado, existem pessoas que v√£o preferir do jeito como est√°, e existem pessoas que optar√£o por colocar o achocolatado antes do leite, e desde que n√£o haja preju√≠zo nos fatores citados acima, tudo bem!
Agora, pegue papel e caneta ou abra um bloco de texto e gaste 5 minutos escrevendo um algoritmo sobre como se vestir para uma festa.
Ap√≥s escrever o algoritmo, responda as seguintes perguntas:
Eu resolvi o problema?
Havia outras maneiras de resolver o problema?
A maneira que eu escolhi foi a mais eficiente poss√≠vel, ou havia como fazer a mesma coisa com menos passos?
Seria poss√≠vel inverter ou retirar algum passo?
Se eu fosse um computador, conseguiria entender todas as instru√ß√µes?
Existe tamb√©m, no processo de cria√ß√£o de um algoritmo, um conceito muito importante chamado baby steps ou "passos de beb√™".
Antes de falarmos dos baby steps, vamos analisar o seguinte exerc√≠cio:
O enunciado diz:
Utilizando o array abaixo, percorra-o somando todos os valores. Caso o valor final seja maior que 15, imprima-o. Caso seja igual ou menor que 15, imprima a mensagem: "valor menor que 16":
Copiar
let fruits = [3, 4, 10, 1, 12];
A resolu√ß√£o do problema acontece em 3 etapas:
Interpreta√ß√£o;
Cria√ß√£o do algoritmo;
Codifica√ß√£o do algoritmo.
Portanto, primeiro vamos interpretar o que est√° sendo pedido, e essa etapa √© crucial para solucionar o problema. Se interpretarmos errado, o algoritmo e consequentemente o c√≥digo estar√° errado.
Analisando o enunciado, sabemos que:
devemos utilizar o array fruits;
o termo "percorra" indica uma estrutura de repeti√ß√£o, ou loop;
"somando todos os valores" mostra que devemos ter uma vari√°vel que guarda o valor da soma dos valores;
o termo "caso" indica uma estrutura condicional, ou if;
"imprima o valor final" indica um console.log;
Pode parecer um pouco bobo, mas em enunciados complexos, analisar friamente o enunciado nos afasta de cometermos erros e termos que escrever todo os passos seguintes novamente.
Agora vamos criar o algoritmo, e pra isso faremos uso dos baby steps. Eles nos estimulam a dividir grandes e complexos problemas em pequenos e simples.
Adicionar o array;
Criar uma vari√°vel com valor 0;
Criar um loop que percorre o array;
Incrementar a vari√°vel com o valor correspondente a cada loop;
Criar um if com a condi√ß√£o da vari√°vel ser maior que 15;
Caso a vari√°vel obede√ßa a condi√ß√£o;
Imprimir a vari√°vel
Caso n√£o obede√ßa a condi√ß√£o;
Imprimir a mensagem "valor menor que 16";
No momento j√° interpretamos o problema e j√° criamos um algoritmo, baseado nos baby steps, para ele. Como √∫ltima etapa, vamos codific√°-lo, seguindo nosso algoritmo:
Adicionar o array;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
Criar uma vari√°vel com valor 0;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
let sum = 0;
Criar um loop que percorre o array;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
let sum = 0;

for (let index = 0; index < fruits.length; index += 1) {

}
Incrementar a vari√°vel com o valor correspondente a cada loop;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
let sum = 0;

for (let index = 0; index < fruits.length; index += 1) {
  sum += fruits[index];
}
Criar um if com a condi√ß√£o da v√°riavel ser maior que 15;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
let sum = 0;

for (let index = 0; index < fruits.length; index += 1) {
  sum += fruits[index];
}

if (sum > 15) {

} else {

}
Caso a var√≠avel obede√ßa a condi√ß√£o: Imprimir a var√≠avel;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
let sum = 0;

for (let index = 0; index < fruits.length; index += 1) {
  sum += fruits[index];
}

if(sum > 15) {
  console.log(sum);
} else {

}
Caso n√£o obede√ßa a condi√ß√£o: Imprimir a mensagem ‚Äúvalor menor que 16‚Äù;
Copiar
//exercise.js
let fruits = [3, 4, 10, 1, 12];
let sum = 0;

for (let index = 0; index < fruits.length; index += 1) {
  sum += fruits[index];
}

if (sum > 15) {
  console.log(sum);
} else {
  console.log('valor menor que 16');
}
Com o tempo e repeti√ß√£o, muitas dessas etapas se tornam autom√°ticas. Por√©m, √© extremamente √∫til sabermos construir um algoritmo sem codific√°-lo. Por isso, at√© o momento da aula ao vivo, volte aos exerc√≠cios do dia anterior, 4.2, e crie um algoritmo para cada.
Ap√≥s escrever cada algoritmo, responda novamente as seguintes perguntas:
Eu resolvi o problema?
Havia outras maneiras de resolver o problema?
A maneira que eu escolhi foi a mais eficiente poss√≠vel?
Seria poss√≠vel inverter ou retirar algum passo?
Se eu fosse um computador, conseguiria entender todas as intru√ß√µes?
Lembre-se sempre: se voc√™ travar em algum exerc√≠cio, recomece seu racioc√≠nio com baby steps! Certamente voc√™ ser√° capaz de dividir algum passo em outros passos menores. Isso ajudar√° muito na hora de resolver problemas.




Complexidade de c√≥digo
Um c√≥digo muito complexo n√£o √© uma boa pr√°tica no mundo da programa√ß√£o. Isso dificulta n√£o s√≥ o acompanhamento do c√≥digo, mas tamb√©m a testagem ou a implementa√ß√£o de mudan√ßas.
√â normal, principalmente no come√ßo, que o seu c√≥digo apresente erros de complexidade e voc√™ precise encontrar uma maneira de desenvolver a sua l√≥gica de uma forma diferente.
Para medir a complexidade de um c√≥digo, existe a complexidade ciclom√°tica, que √© uma m√©trica de software que considera os caminhos independentes que o algoritmo pode tomar. E, quanto maior for a complexidade ciclom√°tica, mais dif√≠cil √© fazer o acompanhamento do c√≥digo, sua manuten√ß√£o e testagem.
Para manter a complexidade baixa, voc√™ deve sempre tentar simplificar os caminhos poss√≠veis, como, por exemplo, quebrando o seu c√≥digo em partes menores.
Mas que caminhos s√£o esses?
Voc√™ aprendeu sobre if/else, certo? Por exemplo, se o seu c√≥digo apresenta apenas uma condicional (somente um if/else), ele tem dois caminhos, ou faz isso ou faz aquilo. E, quanto mais caminhos tiver, mais complexo vai ser. Existem v√°rias formas de aumentar a quantidade desses caminhos, n√£o s√≥ usando condicionais. Pode-se, tamb√©m, por exemplo, aumentar usando la√ßos de repeti√ß√£o, como for. Mas n√£o foque nisso agora!
N√£o se preocupe em como resolver esse erro por agora, pois voc√™ ir√° entender melhor como fazer isso no conte√∫do de amanh√£! O foco hoje √© s√≥ entender que o erro de complexidade de c√≥digo existe, para voc√™ n√£o ter uma surpresa no futuro.




Vamos praticar!
Partiu praticar esses conceitos em conjunto?!
Aula ao vivo! Vamos para o Slack, onde o link estar√° dispon√≠vel.



Exerc√≠cios
fundamentos
Antes de come√ßar: versionando seu c√≥digo
Para versionar seu c√≥digo, utilize o seu reposit√≥rio de exerc√≠cios. üòâ
Abaixo voc√™ vai ver exemplos de como organizar os exerc√≠cios do dia em uma branch, com arquivos e commits espec√≠ficos para cada exerc√≠cio. Voc√™ deve seguir este padr√£o para realizar os exerc√≠cios a seguir.
Abra a pasta de exerc√≠cios:
Copiar
$ cd ~/trybe-exercicios
Certifique-se de que est√° na branch main e ela est√° sincronizada com a remota. Caso voc√™ tenha arquivos modificados e n√£o comitados, dever√° fazer um commit ou checkout dos arquivos antes deste passo.
Copiar
$ git checkout main
$ git pull
A partir da main, crie uma branch com o nome exercicios/4.3 (bloco 4, dia 3)
Copiar
$ git checkout -b exercicios/4.3
Caso seja o primeiro dia deste m√≥dulo, crie um diret√≥rio para ele e o acesse na sequ√™ncia:
Copiar
$ mkdir fundamentos
$ cd fundamentos
Caso seja o primeiro dia do bloco, crie um diret√≥rio para ele e o acesse na sequ√™ncia:
Copiar
$ mkdir bloco-4-introducao-a-javascript-e-logica-de-programacao
$ cd bloco-4-introducao-a-javascript-e-logica-de-programacao
Crie um diret√≥rio para o dia e o acesse na sequ√™ncia:
Copiar
$ mkdir dia-3-javascript-logica-de-programacao-e-algoritmos
$ cd dia-3-javascript-logica-de-programacao-e-algoritmos
Os arquivos referentes aos exerc√≠cios deste dia dever√£o ficar dentro do diret√≥rio ~/trybe-exercicios/fundamentos/block-4-introducao-a-javascript-e-logica-de-programacao/dia-3-javascript-logica-de-programacao-e-algoritmos. Lembre-se de fazer commits pequenos e com mensagens bem descritivas, preferencialmente a cada exerc√≠cio resolvido.

Verifique os arquivos alterados/adicionados:
Copiar
$ git status
On branch exercicios/4.3
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   exercicio-1

Adicione os arquivos que far√£o parte daquele commit:
Copiar
# Se quiser adicionar os arquivos individualmente
$ git add caminhoParaArquivo

# Se quiser adicionar todos os arquivos de uma vez, por√©m, atente-se
para n√£o adicionar arquivos indesejados acidentalmente
$ git add --all

Fa√ßa o commit com uma mensagem descritiva das altera√ß√µes:
Copiar
$ git commit -m "Mensagem descrevendo altera√ß√µes"
Voc√™ pode visualizar o log de todos os commits j√° feitos naquela branch com git log.
Copiar
$ git log
commit 100c5ca0d64e2b8649f48edf3be13588a77b8fa4 (HEAD -> exercicios/4.3)
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 17:48:01 2019 -0300

    Exercicio 2 - mudando o evento de click para mouseover, tirei o alert e coloquei pra quando clicar aparecer uma imagem do lado direito da tela

commit c0701d91274c2ac8a29b9a7fbe4302accacf3c78
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 16:47:21 2019 -0300

    Exercicio 2 - adicionando um alert, usando fun√ß√£o e o evento click

commit 6835287c44e9ac9cdd459003a7a6b1b1a7700157
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 15:46:32 2019 -0300

    Resolvendo o exerc√≠cio 1 usando eventListener
Agora que temos as altera√ß√µes salvas no reposit√≥rio local precisamos envi√°-las para o reposit√≥rio remoto. No primeiro envio, a branch exercicios/4.3 n√£o vai existir no reposit√≥rio remoto, ent√£o precisamos configurar o remote utilizando a op√ß√£o --set-upstream (ou -u, que √© a forma abreviada).
Copiar
$ git push -u origin exercicios/4.3
Ap√≥s realizar o passo 9, podemos abrir a Pull Request a partir do link que aparecer√° na mensagem do push no terminal, ou na p√°gina do seu reposit√≥rio de exerc√≠cios no GitHub atrav√©s de um bot√£o que aparecer√° na interface. Escolha a forma que preferir e abra a Pull Request. De agora em diante, voc√™ repetir√° o fluxo a partir do passo 7 para cada exerc√≠cio adicionado, por√©m como j√° definimos a branch remota com -u anteriormente, agora podemos simplificar os comandos para:
Copiar
# Quando quiser enviar para o reposit√≥rio remoto
$ git push

# Caso voc√™ queria sincronizar com o remoto, poder√° utilizar apenas
$ git pull
Quando terminar os exerc√≠cios, seus c√≥digos devem estar todos commitados na branch exercicios/4.3, e dispon√≠veis no reposit√≥rio remoto do GitHub. Pra finalizar, compartilhe o link da Pull Request no canal de Code Review para a monitoria e/ou colegas revisarem. Fa√ßa review voc√™ tamb√©m, lembre-se que √© muito importante para o seu desenvolvimento ler o c√≥digo de outras pessoas. ü§úüèºü§õüèº



Agora a pr√°tica
Aprofunde seus conhecimentos
Leia atentamente os enunciados e fa√ßa o que se pede!
Recomendamos que voc√™ utilize o debugger ou o console.log() durante a realiza√ß√£o dos exerc√≠cios, desse modo ser√° mais f√°cil acompanhar o comportamento do c√≥digo e entender o que ocorre em cada uma das linhas. Para saber mais sobre como utilizar o debugger, acesse nosso conte√∫do sobre isso.
1- O fatorial √© a multiplica√ß√£o de um n√∫mero natural pelos seus antecessores, exceto o zero. Por exemplo:
Copiar
O fatorial √© representado pelo sinal !
4! = 4 x 3 x 2 x 1 = 24
Com base nessas informa√ß√µes, crie um algoritmo que retorne o fatorial de 10.
2- Agora, desenvolva um algoritmo que √© capaz de inverter uma palavra. Por exemplo, a palavra "banana" seria invertida para "ananab". Utilize a string abaixo como exemplo, depois troque por outras para verificar se seu algoritmo est√° funcionando corretamente.
Copiar
let word = 'tryber';
3- Considere o array de strings abaixo:
Copiar
let array = ['java', 'javascript', 'python', 'html', 'css'];
Escreva dois algoritmos: um que retorne a maior palavra deste array e outro que retorne a menor. Considere o n√∫mero de caracteres de cada palavra.
4- Um n√∫mero primo √© um n√∫mero inteiro maior do que 1 que possui somente dois divisores, ou seja, √© divis√≠vel por 1 e por ele mesmo. Sabendo disso, escreva um algoritmo que retorne o maior n√∫mero primo entre 2 e 50.




B√¥nus
1- Agora vamos trabalhar com algumas formas geom√©tricas! Fa√ßa um programa que, dado um valor n qualquer, seja n > 1, imprima na tela um quadrado feito de asteriscos de lado de tamanho n. Por exemplo:
Copiar
n = 5

*****
*****
*****
*****
*****
2- Para o segundo exerc√≠cio, fa√ßa o mesmo que antes, mas que imprima um tri√¢ngulo ret√¢ngulo com 5 asteriscos de base. Por exemplo:
Copiar
n = 5

*
**
***
****
*****
3- Agora inverta o lado do tri√¢ngulo. Por exemplo:
Copiar
n = 5

    *
   **
  ***
 ****
*****
Aten√ß√£o! Note que esse exerc√≠cio √© bem mais complexo que o anterior! N√£o basta, aqui, imprimir somente asteriscos. Voc√™ precisar√° de uma l√≥gica para imprimir espa√ßos tamb√©m.
4- Depois, fa√ßa uma pir√¢mide com n asteriscos de base:
Copiar
n = 5

  *
 ***
*****
5- Fa√ßa uma pir√¢mide com n asteriscos de base que seja vazia no meio. Assuma que o valor de n ser√° sempre √≠mpar:
Copiar
Por √∫ltimo, fa√ßamos com que a vari√°vel seja incrementada com o valor correspondente a cada loop;
n = 7

   *
  * *
 *   *
*******
6- Fa√ßa um programa que diz se um n√∫mero definido numa vari√°vel √© primo ou n√£o.
Um n√∫mero primo √© um n√∫mero que s√≥ √© divis√≠vel por 1 e por ele mesmo, ou seja, a divis√£o dele com quaisquer outros n√∫meros d√° resto diferente de zero.
Dica: voc√™ vai precisar de fazer um loop que v√° de 0 ao n√∫mero definido; Al√©m disso, vai precisar de fazer uma checagem a cada itera√ß√£o e armazenar os resultados em algum lugar.





Recursos adicionais (opcional)
W3Schools JavaScript Arrays
Grasshopper - um aplicativo para praticar o b√°sico de programa√ß√£o
Step up your coding game - The new way to improve your programming skills while having fun and getting noticed
Code.org - treinando l√≥gica de programa√ß√£o de maneira l√∫dica
The 9 Best Coding Games to Build Your Programming Skills
CheckiO - Coding games for beginners and advanced programmers
