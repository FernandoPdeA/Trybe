O que vamos aprender?
Hoje voc√™ vai aprender um pouco sobre fluxo de exce√ß√£o! Ou seja, como tratar os erros do seu c√≥digo utilizando os m√©todos throw e try/catch. Al√©m disso, voc√™ ver√° algumas fun√ß√µes que interagem com objetos. Esses m√©todos te ajudar√£o bastante quando for necess√°ria alguma leitura de seus valores ou chaves, ou quando precisar copi√°-los. Esse √© um passo muito importante para o bom e mais avan√ßado uso do JavaScript. Objetos s√£o muito presentes em todas as l√≥gicas do ES6. Os m√©todos que veremos s√£o:
Object.keys;
Object.entries;
Object.assign;
Object.values.



Voc√™ ser√° capaz de:
Lan√ßar erros com throw e captur√°-los com o bloco try/catch;
Acessar todas as chaves de um objeto com o m√©todo Object.keys;
Acessar os pares chave-valor de um objeto com o m√©todo Object.entries;
Acessar todos os valores de um objeto com o m√©todo Object.values;
Copiar um objeto com o m√©todo Object.assign;
Adicionar propriedades a um objeto.



Por que isso √© importante?
Em JavaScript, o tratamento de erros em um c√≥digo √© fundamental, pois ajudar√° voc√™ a entender melhor o que est√° ocasionando tais erros. Al√©m disso, aprender a lidar com objetos e suas propriedades √© essencial, uma vez que voc√™ se deparar√° com eles frequentemente. Voc√™ ver√° m√©todos que servem para melhorar o uso de um objeto, facilitando o acesso a suas informa√ß√µes e te permitindo adicionar novas funcionalidades a ele. Um exemplo pr√°tico disso √© que voc√™ n√£o precisar√° mais utilizar um for para percorrer um objeto para pegar sua lista de chaves ou de valores.



Conte√∫dos
At√© aqui, voc√™ j√° aprendeu a criar fun√ß√µes e obter os mais diversos resultados com elas, mas e quando as coisas d√£o errado? Como tratar os erros? Hoje voc√™ ver√° como dar maior legibilidade a esses erros e, consequentemente, ao seu c√≥digo como um todo.
Voc√™ tamb√©m viu e utilizou bastante os objetos no JavaScript e hoje aprender√° sobre m√©todos com objetos bastante √∫teis para a l√≥gica do seu c√≥digo. No decorrer do conte√∫do, execute os exemplos na sua m√°quina para ver melhor como cada m√©todo funciona. Sinta-se livre para mudar os objetos ou o c√≥digo para explorar mais cada exemplo.



Throw e Try/Catch
Para come√ßar, relembre o conte√∫do da aula anterior com este exemplo de arrow function:
Copiar
const sum = (value1, value2) => value1 + value2;
A fun√ß√£o acima √© bastante simples: recebe dois par√¢metros e retorna a soma entre eles. Copie o c√≥digo e chame a fun√ß√£o com dois par√¢metros num√©ricos (por exemplo, 2 e 3). N√£o esque√ßa do console.log para que seja poss√≠vel ver o retorno.
Copiar
const sum = (value1, value2) => value1 + value2;

console.log(sum(2, 3));
Tudo funciona perfeitamente quando voc√™ tem o controle do c√≥digo, certo? Mas digamos que voc√™ est√° desenvolvendo uma aplica√ß√£o onde uma pessoa ir√° fornecer os valores. Sabemos que pessoas cometem erros e podem, por exemplo, tentar somar o n√∫mero 2 com a string '3'. O que aconteceria nesse caso?
Copiar
const sum = (value1, value2) => value1 + value2;

console.log(sum(2, '3')); // resultado: 23
2 + '3' = 23?? Uma intera√ß√£o bastante inusitada, concorda? O que aconteceu foi que a sua fun√ß√£o, ao perceber que estava fazendo uma opera√ß√£o com par√¢metros de tipos distintos, tentou adapt√°-los para que o c√≥digo n√£o quebrasse - no caso, o primeiro par√¢metro foi convertido para uma string, e a opera√ß√£o realizada foi uma concatena√ß√£o de strings atrav√©s do sinal de +.
Esse comportamento ocorre porque considera-se o JavaScript como uma linguagem din√¢mica. Ou seja, quando se declara uma vari√°vel, n√£o √© necess√°rio atrelar ela a nenhum tipo, o que permite inclusive que ela mude de tipo ao longo da execu√ß√£o do c√≥digo.
Por mais que esse aspecto traga alguma flexibilidade, ele tamb√©m produz comportamentos inesperados que podem ser dif√≠ceis de identificar. Por isso, voc√™ enquanto boa pessoa programadora deve ser capaz de prever esses comportamentos e evitar que eles ocorram. üòâ
Vamos adicionar uma condicional que impede a pessoa usu√°ria de quebrar a sua calculadora.
Copiar
const sum = (value1, value2) => {
  if (typeof value1 !== 'number' || typeof value2 !== 'number') {
    return 'Os valores devem ser num√©ricos';
  }
  return value1 + value2;
};

console.log(sum(2, '3'));
Pronto, agora o seu c√≥digo avisa para a pessoa usu√°ria que a fun√ß√£o sum s√≥ aceita n√∫meros. Aparentemente est√° tudo funcionando como deveria, mas essa ainda n√£o √© a melhor forma de se tratar um erro em JavaScript. Na pr√°tica, a fun√ß√£o sum est√° retornando uma string, e essa n√£o √© o objetivo de uma fun√ß√£o que soma dois n√∫meros, certo? Voc√™ precisa indicar de alguma forma que ocorreu um erro.
Para isso existe o fluxo de exce√ß√£o: quando um erro acontece em Javascript, devemos lan√ßar uma exce√ß√£o, que vai interromper o funcionamento do c√≥digo. Essa √© a fun√ß√£o do throw:
Copiar
const sum = (value1, value2) => {
  if (typeof value1 !== 'number' || typeof value2 !== 'number') {
    throw new Error('Os valores devem ser num√©ricos');
  }
  return value1 + value2;
};

console.log(sum(2, '3'));
Percebeu a diferen√ßa? Agora a execu√ß√£o da fun√ß√£o sum foi interrompida e temos uma mensagem de erro no console, bem como uma indica√ß√£o da linha onde esse erro ocorre.

Exemplo de erro lan√ßado com throw.
Mas vamos detalhar por partes o que foi feito:
A palavra reservada throw serve para lan√ßar uma exce√ß√£o criada por voc√™. No caso, definimos que n√£o seria aceito um par√¢metro que n√£o fosse do tipo number, ent√£o criamos esse "erro customizado". Caso contr√°rio, a fun√ß√£o sum apresentaria um comportamento incorreto. Se quiser saber mais detalhes, consulte a documenta√ß√£o.
O operador new serve para criar um objeto personalizado ou nativo do JavaScript. Mais sobre o new aqui.
A palavra Error √© um objeto nativo do JavaScript que representa um erro. Quando voc√™ o chama com o operador new, voc√™ cria uma c√≥pia deste objeto, que ser√° lan√ßada como uma exce√ß√£o no seu c√≥digo. Veja mais sobre Error na documenta√ß√£o oficial.
Voc√™ programou o c√≥digo para lan√ßar uma exce√ß√£o caso acontece√ßa um erro, mas o fluxo do c√≥digo ainda pode ser melhorado. Voc√™ precisa, por exemplo, capturar esse erro para melhor trat√°-lo. √â a√≠ que entra o bloco try/catch. Enquanto o try tenta executar o c√≥digo com sucesso, o catch √© chamado caso ocorra um erro.
Aproveitando a ocasi√£o, seria uma √≥tima ideia refatorar a fun√ß√£o sum para que ela n√£o tenha funcionalidades demais.
Copiar
const verifyIsNumber = (value1, value2) => {
  if (typeof value1 !== 'number' || typeof value2 !== 'number') {
    throw new Error('Os valores devem ser num√©ricos');
  }
};

const sum = (value1, value2) => {
  try {
    verifyIsNumber(value1, value2);
    return value1 + value2;
  } catch (error) {
    return error.message;
  }
};

console.log(sum(2, '3'));
Agora sim! Voc√™ criou um fluxo para quando nosso c√≥digo √© executado com sucesso, representado pelo bloco try, que tenta fazer a soma de dois valores. Esse bloco chama a fun√ß√£o rec√©m-criada verifyIsNumber, que verifica se os par√¢metros passados s√£o n√∫meros. Quando se depara com um valor que n√£o √© um n√∫mero, o c√≥digo lan√ßa um erro com o throw, que √© capturado pelo catch no fluxo de exce√ß√£o, atrav√©s da vari√°vel error (aqui podemos usar qualquer nome). Dentro do catch retornamos a chave error.message, uma propriedade do objeto nativo Error que cont√©m a mensagem de erro criada anteriormente.
Como sempre, d√™ uma olhada na documenta√ß√£o oficial para aprofundar seus conhecimentos.
Para refor√ßar ainda mais o conceito de try/catch, assista o v√≠deo a seguir:





Objetos: Parte I - Adicionando novas chaves (keys)
Para come√ßar, veja o exemplo abaixo de um objeto que cont√©m as informa√ß√µes de um cliente de uma loja:
Copiar
const customer = {
  firstName: 'Roberto',
  age: 22,
  job: 'Teacher',
};
Imagine um cen√°rio em que voc√™ precisa completar as informa√ß√µes do cliente adicionando uma nova propriedade para armazenar seu sobrenome. Uma das formas j√° vistas at√© ent√£o √© reescrever o objeto, dessa vez j√° com a nova propriedade lastName.
Copiar
const customer = {
  firstName: 'Roberto',
  lastName: 'Faria', // Propriedade adicionada.
  age: 22,
  job: 'Teacher',
};
Existem tamb√©m outras formas de adicionar essa propriedade de maneira muito mais simples e pr√°tica, sem a necessidade de reescrever o objeto e suas propriedades. Veja o exemplo abaixo:
Copiar
const customer1 = {
  firstName: 'Roberto',
  age: 22,
  job: 'Teacher',
};

console.log(customer1);

customer1.lastName = 'Faria';
console.log(customer1);

const customer2 = {
  firstName: 'Maria',
  age: 23,
  job: 'Medic',
};

console.log(customer2);
customer2['lastName'] = 'Silva';
console.log(customer2);
No exemplo acima, ao inv√©s de reescrever o objeto inteiro, apenas adicionamos a nova propriedade. Para isso, basta seguir a sintaxe abaixo:
objeto.nomeDaPropriedade.
objeto[variavelQueContemONomeDaPropriedade].
Agora, suponha que seja necess√°rio adicionar algumas novas propriedades ao objeto, como a naturalidade, a data de nascimento e o estado civil.
Essas novas propriedades ser√£o adicionadas de acordo com o valor de algumas vari√°veis.
Copiar
const customer = {
  firstName: 'Roberto',
  age: 22,
  job: 'Teacher',
};

let newKey = 'lastName';
const lastName = 'Ferreira';
customer[newKey] = lastName;
newKey = 'fullName';
const fullName = `${customer.firstName} ${customer.lastName}`;
customer[newKey] = fullName;
console.log(customer);
No exemplo acima, voc√™ viu que h√° diferentes formas de associar chaves e valores a um objeto.
Agora, para praticar, crie uma fun√ß√£o que receba tr√™s par√¢metros, sendo eles: um objeto, o nome de uma chave e o seu valor. O retorno dessa fun√ß√£o deve ser o objeto j√° com a nova chave adicionada nele.




Objetos: Parte II - Object.keys
Como voc√™ j√° sabe, objetos s√£o um dos tipos de dados em JavaScript que possuem uma estrutura de chave e valor. D√™ uma olhada no exemplo a seguir e pense como voc√™ poderia listar as chaves desse objeto:
Copiar
const coolestTvShow = {
  name: "BoJack Horseman",
  genre: "adult animation",
  createdBy: "Raphael Bob-Waksberg",
  favoriteCharacter: "Princess Carolyn",
  quote: "Princess Carolyn always lands on her feet.",
  seasons: 6,
};
Com o que voc√™ aprendeu at√© o momento de objetos, voc√™ poderia utilizar a estrutura de repeti√ß√£o for...in. Por exemplo:
Copiar
const coolestTvShow = {
  name: "BoJack Horseman",
  genre: "adult animation",
  author: "Raphael Bob-Waksberg",
  favoriteCharacter: "Princess Carolyn",
  quote: "Princess Carolyn always lands on her feet.",
  seasons: 6,
};

for (const property in coolestTvShow) {
  console.log(property);
}

// name
// genre
// author
// favoriteCharacter
// quote
// seasons
Mas e se dissermos que h√° uma maneira mais robusta de trabalhar com objetos e seus valores? O m√©todo Object.keys como o pr√≥prio nome diz, √© utilizado para listar as chaves de um objeto, retornando-as em um array. Cada entrada do array retornado ser√° uma string com o valor de cada chave do objeto. Fant√°stico n√£o √© mesmo? Vamos ver como ficaria nosso exemplo utilizando este m√©todo:
Copiar
const coolestTvShow = {
  name: "BoJack Horseman",
  genre: "adult animation",
  createdBy: "Raphael Bob-Waksberg",
  favoriteCharacter: "Princess Carolyn",
  quote: "Princess Carolyn always lands on her feet.",
  seasons: 6,
};

// for (const property in coolestTvShow) {
//   console.log(property);
// }

console.log(Object.keys(coolestTvShow));

// [ 'name', 'genre', 'createdBy', 'favoriteCharacter', 'quote', 'seasons' ]
Agora que voc√™ j√° sabe o que √© o Object.keys, que tal dar uma olhadinha na sua documenta√ß√£o? Leia at√© a se√ß√£o sobre Polyfill.
Ap√≥s a leitura, veja mais um exemplo de aplica√ß√£o do Object.keys. Nesse exemplo est√£o listadas as habilidades de uma pessoa desenvolvedora.
Copiar
const student1 = {
  Html: 'Muito Bom',
  Css: 'Bom',
  JavaScript: '√ìtimo',
  SoftSkills: '√ìtimo',
};

const student2 = {
  Html: 'Bom',
  Css: '√ìtimo',
  JavaScript: 'Ruim',
  SoftSkills: '√ìtimo',
  Git: 'Bom', // chave adicionada
};
Tente criar uma fun√ß√£o que exiba as habilidades do objeto student. Cada habilidade deve ser exibida no formato "Nome da habilidade, N√≠vel: valor da chave referente √† habilidade". Ap√≥s tentar criar a fun√ß√£o, veja a sugest√£o de resposta logo abaixo e compare com a sua solu√ß√£o.
Copiar
const student1 = {
  Html: 'Muito Bom',
  Css: 'Bom',
  JavaScript: '√ìtimo',
  SoftSkills: '√ìtimo',
};

const student2 = {
  Html: 'Bom',
  Css: '√ìtimo',
  JavaScript: 'Ruim',
  SoftSkills: '√ìtimo',
  Git: 'Bom', // chave adicionada
};

const listSkills = (student) => {
  const arrayOfSkills = Object.keys(student);
  for (const index in arrayOfSkills) {
    console.log(`${arrayOfSkills[index]}, N√≠vel: ${student[arrayOfSkills[index]]}`);
  }
};

console.log('Estudante 1');
listSkills(student1);

console.log('Estudante 2');
listSkills(student2);
Verifique que usamos o m√©todo Object.keys e a estrutura de repeti√ß√£o for...in em conjunto. Al√©m disso, perceba que a mesma fun√ß√£o √© utilizada para iterar sobre os dois objetos, mesmo o segundo tendo uma chave a mais que o outro.




Objetos: Parte III - Object.values
O Object.values segue a mesma l√≥gica que o Object.keys, a diferen√ßa est√° em que ele lista os valores de cada chave. Voltando ao nosso exemplo anterior, como far√≠amos para listar os valores de cada chave do nosso objeto coolestTvShow? Utilizando o for...inseria algo como:
Copiar
const coolestTvShow = {
  name: "BoJack Horseman",
  genre: "adult animation",
  createdBy: "Raphael Bob-Waksberg",
  favoriteCharacter: "Princess Carolyn",
  quote: "Princess Carolyn always lands on her feet.",
  seasons: 6,
};

for (const property in coolestTvShow) {
  console.log(coolestTvShow[property]);
}

// BoJack Horseman
// adult animation
// Raphael Bob-Waksberg
// Princess Carolyn
// Princess Carolyn always lands on her feet.
// 6
Podemos ent√£o refatorar para utilizar o Object.values, nosso c√≥digo ficaria assim:
Copiar
const coolestTvShow = {
  name: "BoJack Horseman",
  genre: "adult animation",
  createdBy: "Raphael Bob-Waksberg",
  favoriteCharacter: "Princess Carolyn",
  quote: "Princess Carolyn always lands on her feet.",
  seasons: 6,
};

// for (const property in coolestTvShow) {
//   console.log(coolestTvShow[property]);
// }

console.log(Object.values(coolestTvShow));

// [
//   'BoJack Horseman',
//   'adult animation',
//   'Raphael Bob-Waksberg',
//   'Princess Carolyn',
//   'Princess Carolyn always lands on her feet.'
//    6
// ]
Vamos dar uma olhadinha na documenta√ß√£o para entender melhor seu funcionamento.
Para fixar melhor veja abaixo mais um exemplo, em que foram implementadas, de formas diferentes, duas fun√ß√µes que retornam a mesma lista de valores. Veja como fica muito mais f√°cil obter os valores de um objeto com o uso do Object.values.
Copiar
const student = {
  Html: 'Muito Bom',
  Css: 'Bom',
  JavaScript: '√ìtimo',
  SoftSkill: '√ìtimo',
};

const listSkillsValuesWithFor = (student) => {
  const skills = [];
  for(skill in student) {
    skills.push(student[skill]);
  }

  return skills;
};

const listSkillsValuesWithValues = (student) => Object.values(student);

// Sem Object.values
console.log(listSkillsValuesWithFor(student));

// Com Object.values
console.log(listSkillsValuesWithValues(student));
Observe como a fun√ß√£o listSkillsValuesWithValues √© bem mais simples e resolve o problema da listagem de valores de forma mais direta.




Objetos: Parte IV - Object.entries
Outro m√©todo muito √∫til para se trabalhar com objetos √© o Object.entries. Um pouco diferente dos m√©todos apresentados anteriormente, este retorna um array cujos elementos s√£o tamb√©m arrays para cada conjunto chave e valor do objeto. Ficou confuso? N√£o se preocupe, vamos ao nosso exemplo e ver qual seria a sa√≠da:
Copiar
const coolestTvShow = {
  name: "BoJack Horseman",
  genre: "adult animation",
  createdBy: "Raphael Bob-Waksberg",
  favoriteCharacter: "Princess Carolyn",
  quote: "Princess Carolyn always lands on her feet.",
  seasons: 6,
};

console.log(Object.entries(coolestTvShow));

// [
//   [ 'name', 'BoJack Horseman' ],
//   [ 'genre', 'adult animation' ],
//   [ 'createdBy', 'Raphael Bob-Waksberg' ],
//   [ 'favoriteCharacter', 'Princess Carolyn' ],
//   [ 'quote', 'Princess Carolyn always lands on her feet.' ],
//   [ 'seasons', 6 ]
// ]
Como voc√™ pode perceber, ao aplicar o Object.entries no nosso objeto, o retorno foi um array de arrays. Onde a primeira entrada de cada array √© a chave do objeto em formato de string, e, o segundo valor √© seu respectivo valor, que pode ser uma string ou outro tipo de dado, como por exemplo o n√∫mero de temporadas do exemplo que √© um number. Bem legal, n√£o √© mesmo? Vamos ent√£o agora ler a documenta√ß√£o at√© a se√ß√£o "Convertendo um Object em um Map".
Ap√≥s a leitura que tal analisarmos mais um exemplo? Ent√£o bora l√°:
Copiar
const pa√≠ses = {
  Fran√ßa: 'Paris',
  Brasil: 'Bras√≠lia',
  Espanha: 'Madrid',
  Portugal: 'Lisboa',
};
const pairKeyValue = Object.entries(pa√≠ses);
console.log(pairKeyValue);
Observe que o retorno dele √© um array e que cada um de seus elementos √© um outro array com apenas dois dados, a chave do objeto e o seu valor. Para ver os valores separadamente, adicione o for abaixo ao c√≥digo anterior e execute-o novamente.
Copiar
for(index in pairKeyValue) {
  console.log('--------');
  console.log('Pa√≠s:', pairKeyValue[index][0]);
  console.log('Capital:', pairKeyValue[index][1]);
};
Que tal refor√ßar ainda mais os conceitos de Object.keys, Object.values e Object.entries com o v√≠deo abaixo?





Objetos: Parte V - Object.assign
Esse m√©todo √© utilizado para copiar os valores de todas as propriedades de um ou mais objetos para um objeto destino. Sua estrutura √©:
Copiar
// A fun√ß√£o recebe um n√∫mero qualquer de par√¢metros. Todos s√£o agregados como valores para adicionar ao objeto de destino!

Object.assign(destino, objeto1);
Object.assign(destino, objeto1, objeto2);
Object.assign(destino, objeto1, objeto2, objeto3, objeto4);
Como voc√™ pode ver, ele recebe pelo menos dois par√¢metros, de forma que o primeiro sempre ser√° o objeto de destino, e os par√¢metros restantes ser√£o os valores que ser√£o adicionados a esse objeto destino.
Veja o exemplo abaixo:
Copiar
const person = {
  name: 'Alberto',
  lastName: 'Gomes',
  age: 20,
};

const info = {
  age: 23,
  job: 'engenheiro',
};

const family = {
  children: ['Maria', 'Jo√£o'],
  wife: 'Ana',
};

Object.assign(person, info, family)
console.log(person)

/* Output
  { name: 'Alberto',
  lastName: 'Gomes',
  age: 23,
  job: 'engenheiro',
  children: [ 'Maria', 'Jo√£o' ],
  wife: 'Ana'
  } */
Como voc√™ pode ver, o m√©todo Object.assign adicionou as propriedades de info e de family ao objeto person. Observe tamb√©m que a chave age aparece tanto em person como em info e √© sobrescrita pelo valor contido em info. Isso acontece quando h√° propriedades repetidas entre o objeto destino e os objetos passados por par√¢metro, de forma que a propriedade do objeto destino sempre utilizar√° o √∫ltimo valor dispon√≠vel.
Agora, observe o exemplo abaixo.
Copiar
const person = {
  name: 'Roberto',
};

const lastName = {
  lastName: 'Silva',
};

const clone = Object.assign(person, lastName);

console.log(clone); // { name: 'Roberto', lastName: 'Silva' }
console.log(person); // { name: 'Roberto', lastName: 'Silva' }
Como p√¥de ver acima, o clone √© exatamente igual ao objeto person, e se voc√™ mudar qualquer propriedade nele, observar√° que o objeto person tamb√©m ser√° modificado. Isso ocorre devido ao fato de que o objeto retornado pelo m√©todo Object.assign √© o pr√≥prio objeto destino, que foi alterado adicionando as novas propriedades.
Que tal fazer um teste para confirmar isso?
Copiar
clone.name = 'Maria';

console.log('Mudando a propriedade name atrav√©s do objeto clone')
console.log(clone); // Output: { name: 'Maria', lastName: 'Silva' }
console.log(person); // Output: { name: 'Maria', lastName: 'Silva' }
console.log('--------------');

person.lastName = 'Ferreira';

console.log('Mudando a propriedade lastName atrav√©s do objeto person');
console.log(clone); // Output: { name: 'Maria', lastName: 'Ferreira' }
console.log(person); // Output: { name: 'Maria', lastName: 'Ferreira' }
Quando se faz o que foi feito no exemplo mais acima, ao criar uma nova vari√°vel para armazenar o retorno do m√©todo Object.assign, cria-se apenas um outro "caminho" para modificar ou acessar os dados do objeto destino (nesse caso, person). No exemplo abaixo, √© apresentada outra forma de se copiar um objeto.
Copiar
const obj = { value1: 10, value2: 11 };
const cloneObj = obj;
Se voc√™ modificar o cloneObj, ver√° que novamente teremos o mesmo resultado anterior, de forma que o obj tamb√©m √© alterado. Ok, tendo isso em vista, como faremos para mudar os dados do novo objeto criado sem modificar o objeto inicial?
Para resolver esse problema, podemos passar como primeiro par√¢metro do Object.assign um objeto vazio {} e armazenar seu retorno em uma nova vari√°vel. Veja como fazer isso no exemplo abaixo.
Copiar

const person = {
  name:'Roberto',
};

const lastName = {
  lastName: 'Silva',
};

const newPerson = Object.assign({},person,lastName);
newPerson.name = 'Gilberto';
console.log(newPerson);
console.log(person);
Agora, apenas o objeto newPerson ser√° modificado.




Vamos praticar!
Agora que voc√™ j√° ficou fera em fluxos de exce√ß√£o e nos usos do Object, que tal vermos algumas aplica√ß√µes para os dois casos? üíö
Aula ao vivo! Vamos para o Slack, onde o link estar√° dispon√≠vel.



Exerc√≠cios
Hora de p√¥r a m√£o na massa!
fundamentos
Antes de come√ßar: versionando seu c√≥digo
Para versionar seu c√≥digo, utilize o seu reposit√≥rio de exerc√≠cios. üòâ
Abaixo voc√™ vai ver exemplos de como organizar os exerc√≠cios do dia em uma branch, com arquivos e commits espec√≠ficos para cada exerc√≠cio. Voc√™ deve seguir este padr√£o para realizar os exerc√≠cios a seguir.
Abra a pasta de exerc√≠cios:
Copiar
$ cd ~/trybe-exercicios
Certifique-se de que est√° na branch main e ela est√° sincronizada com a remota. Caso voc√™ tenha arquivos modificados e n√£o comitados, dever√° fazer um commit ou checkout dos arquivos antes deste passo.
Copiar
$ git checkout main
$ git pull
A partir da main, crie uma branch com o nome exercicios/7.2 (bloco 7, dia 2)
Copiar
$ git checkout -b exercicios/7.2
Caso seja o primeiro dia deste m√≥dulo, crie um diret√≥rio para ele e o acesse na sequ√™ncia:
Copiar
$ mkdir fundamentos
$ cd fundamentos
Caso seja o primeiro dia do bloco, crie um diret√≥rio para ele e o acesse na sequ√™ncia:
Copiar
$ mkdir bloco-7-introducao-a-javascript-es6-e-testes-unitarios
$ cd bloco-7-introducao-a-javascript-es6-e-testes-unitarios
Crie um diret√≥rio para o dia e o acesse na sequ√™ncia:
Copiar
$ mkdir dia-2-javascript-es6-fluxo-de-excecao-e-objetos
$ cd dia-2-javascript-es6-fluxo-de-excecao-e-objetos
Os arquivos referentes aos exerc√≠cios deste dia dever√£o ficar dentro do diret√≥rio ~/trybe-exercicios/fundamentos/block-7-introducao-a-javascript-es6-e-testes-unitarios/dia-2-javascript-es6-fluxo-de-excecao-e-objetos. Lembre-se de fazer commits pequenos e com mensagens bem descritivas, preferencialmente a cada exerc√≠cio resolvido.

Verifique os arquivos alterados/adicionados:
Copiar
$ git status
On branch exercicios/7.2
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   exercicio-1

Adicione os arquivos que far√£o parte daquele commit:
Copiar
# Se quiser adicionar os arquivos individualmente
$ git add caminhoParaArquivo

# Se quiser adicionar todos os arquivos de uma vez, por√©m, atente-se
para n√£o adicionar arquivos indesejados acidentalmente
$ git add --all

Fa√ßa o commit com uma mensagem descritiva das altera√ß√µes:
Copiar
$ git commit -m "Mensagem descrevendo altera√ß√µes"
Voc√™ pode visualizar o log de todos os commits j√° feitos naquela branch com git log.
Copiar
$ git log
commit 100c5ca0d64e2b8649f48edf3be13588a77b8fa4 (HEAD -> exercicios/7.2)
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 17:48:01 2019 -0300

    Exercicio 2 - mudando o evento de click para mouseover, tirei o alert e coloquei pra quando clicar aparecer uma imagem do lado direito da tela

commit c0701d91274c2ac8a29b9a7fbe4302accacf3c78
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 16:47:21 2019 -0300

    Exercicio 2 - adicionando um alert, usando fun√ß√£o e o evento click

commit 6835287c44e9ac9cdd459003a7a6b1b1a7700157
Author: Tryber Bot <tryberbot@betrybe.com>
Date:   Fry Sep 27 15:46:32 2019 -0300

    Resolvendo o exerc√≠cio 1 usando eventListener
Agora que temos as altera√ß√µes salvas no reposit√≥rio local precisamos envi√°-las para o reposit√≥rio remoto. No primeiro envio, a branch exercicios/7.2 n√£o vai existir no reposit√≥rio remoto, ent√£o precisamos configurar o remote utilizando a op√ß√£o --set-upstream (ou -u, que √© a forma abreviada).
Copiar
$ git push -u origin exercicios/7.2
Ap√≥s realizar o passo 9, podemos abrir a Pull Request a partir do link que aparecer√° na mensagem do push no terminal, ou na p√°gina do seu reposit√≥rio de exerc√≠cios no GitHub atrav√©s de um bot√£o que aparecer√° na interface. Escolha a forma que preferir e abra a Pull Request. De agora em diante, voc√™ repetir√° o fluxo a partir do passo 7 para cada exerc√≠cio adicionado, por√©m como j√° definimos a branch remota com -u anteriormente, agora podemos simplificar os comandos para:
Copiar
# Quando quiser enviar para o reposit√≥rio remoto
$ git push

# Caso voc√™ queria sincronizar com o remoto, poder√° utilizar apenas
$ git pull
Quando terminar os exerc√≠cios, seus c√≥digos devem estar todos commitados na branch exercicios/7.2, e dispon√≠veis no reposit√≥rio remoto do GitHub. Pra finalizar, compartilhe o link da Pull Request no canal de Code Review para a monitoria e/ou colegas revisarem. Fa√ßa review voc√™ tamb√©m, lembre-se que √© muito importante para o seu desenvolvimento ler o c√≥digo de outras pessoas. ü§úüèºü§õüèº




Agora a pr√°tica
üöÄ Se liga nesse foguete!
Os exerc√≠cios destacados com üöÄ s√£o os fundamentais pra voc√™ ir bem no projeto! Todos os exerc√≠cios v√£o contribuir com sua forma√ß√£o mas fique de olho nesses! üëÄ



Parte I
Lembra da calculadora que fizemos como exemplo anteriormente? Hora de lev√°-la para um n√≠vel mais avan√ßado!
Copie e cole o c√≥digo abaixo no seu editor de texto:
Copiar
<!DOCTYPE html>
<html lang='pt-BR'>
<head>
  <meta charset='UTF-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <title>Calculadora</title>
</head>
<body>
  <p>Informe dois n√∫meros para realizar a soma:</p>
  <label for='value1'>Valor 1:</label>
  <input type='text' id='value1'>
  <label for='value2'>Valor 2:</label>
  <input type='text' id='value2'>
  <button id='button'>Somar</button>
  <p id='result'></p>
  <script>
    function sum() {
      const value1 = document.getElementById('value1').value;
      const value2 = document.getElementById('value2').value;
      const result = Number(value1) + Number(value2);
      document.getElementById('result').innerHTML = `Resultado: ${result}`;
      document.getElementById('value1').value = '';
      document.getElementById('value2').value = '';
    }
    window.onload = () => {
      const button = document.getElementById('button');
      button.addEventListener('click', sum);
    }
  </script>
</body>
</html>
Tire um tempinho para entender o c√≥digo acima:
A aplica√ß√£o pede ao usu√°rio que informe dois n√∫meros para realizar uma soma. Esses n√∫meros s√£o inseridos atrav√©s dos inputs;
Ao clicar o bot√£o, a fun√ß√£o sum √© chamada, capturando o valor escrito nos inputs e realizando a opera√ß√£o. Antes, √© necess√°ria a convers√£o do valor usando o Number(), pois ele chega √† fun√ß√£o em forma de string, existem outras formas de converter uma string em um n√∫mero, como o parseInt() e o parseFloat();
Ao final, a fun√ß√£o sum imprime o valor em um par√°grafo e limpa os inputs para que a pessoa usu√°ria possa inserir novos valores.
Aparentemente est√° tudo funcionando, mas a aplica√ß√£o n√£o possui fluxo de exce√ß√£o. Ou seja, caso ocorra um erro, eles n√£o ser√£o tratados. Que tal resolver isso?
1 üöÄ - Crie erros personalizados.
Tente executar a aplica√ß√£o com um dos valores em branco. Notou que o retorno n√£o √© muito descritivo?
Utilize o throw new Error e o bloco try/catch.
Evite fun√ß√µes que tenham muitas responsabilidades distintas.
Caso a pessoa usu√°ria nao preencha nenhum input, ou preencha apenas um input, lance um erro.
Caso os valores inseridos nos inputs pela pessoa usu√°ria n√£o sejam n√∫meros, lance um erro. Para isso voc√™ pode utilizar a fun√ß√£o isNan().
Adicione o texto do erro no par√°grafo com id result, para que a pessoa usu√°ria saiba o que aconteceu. Lembre-se de usar erros descritivos!
Utilize o finally para apagar os valores dos inputs ao final do bloco try/catch.
Dica: Cuidado ao utilizar o isNaN pois valores considerados falsy s√£o transformados em 0, podendo assim gerar um falso positivo. E lembre-se que, no javascript para se separar a parte inteira da decimal de um n√∫mero, voc√™ deve utilizar o . exemplo: 1.5, e n√£o a , exemplo: 1,5.




Parte II
Para os exerc√≠cios a seguir, use o seguinte c√≥digo.
Copiar
const order = {
  name: 'Rafael Andrade',
  phoneNumber: '11-98763-1416',
  address: {
    street: 'Rua das Flores',
    number: '389',
    apartment: '701',
  },
  order: {
    pizza: {
      marguerita: {
        amount: 1,
        price: 25,
      },
      pepperoni: {
        amount: 1,
        price: 20,
      }
    },
    drinks: {
      coke: {
        type: 'Coca-Cola Zero',
        price: 10,
        amount: 1,
      }
    },
    delivery: {
      deliveryPerson: 'Ana Silveira',
      price: 5,
    }
  },
  payment: {
    total: 60,
  },
};

const customerInfo = (order) => {
  // Adicione abaixo as informa√ß√µes necess√°rias.

}

customerInfo(order);

const orderModifier = (order) => {
  // Adicione abaixo as informa√ß√µes necess√°rias.

}

orderModifier(order);
Agora voc√™ vai fazer alguns exerc√≠cios de fixa√ß√£o.
Complete a fun√ß√£o customerInfo() para que seu retorno seja similar a "Ol√° Ana Silveira, entrega para: Rafael Andrade, Telefone: 11-98763-1416, R. Rua das Flores, N¬∫: 389, AP: 701".
Note que o par√¢metro da fun√ß√£o j√° est√° sendo passado na chamada da fun√ß√£o.





Complete a fun√ß√£o orderModifier() para que seu retorno seja similar a "Ol√° Luiz Silva, o total do seu pedido de marguerita, pepperoni e Coca-Cola Zero √© R$ 50,00."
Modifique o nome da pessoa compradora.
Modifique o valor total da compra para R$ 50,00.




Parte III
Para os exerc√≠cios a seguir, use o seguinte c√≥digo.
Copiar
const lesson1 = {
  materia: 'Matem√°tica',
  numeroEstudantes: 20,
  professor: 'Maria Clara',
  turno: 'manh√£',
};

const lesson2 = {
  materia: 'Hist√≥ria',
  numeroEstudantes: 20,
  professor: 'Carlos',
};

const lesson3 = {
  materia: 'Matem√°tica',
  numeroEstudantes: 10,
  professor: 'Maria Clara',
  turno: 'noite',
};
Crie uma fun√ß√£o para adicionar o turno da noite na lesson2. Essa fun√ß√£o deve possuir tr√™s par√¢metros, sendo eles: o objeto a ser modificado, a chave que dever√° ser adicionada e o valor dela.
Crie uma fun√ß√£o para listar as keys de um objeto. Essa fun√ß√£o deve receber um objeto como par√¢metro.
Crie uma fun√ß√£o para mostrar o tamanho de um objeto. Essa fun√ß√£o deve receber um objeto como par√¢metro.
Crie uma fun√ß√£o para listar os valores de um objeto. Essa fun√ß√£o deve receber um objeto como par√¢metro.
Crie um objeto de nome allLessons, que deve agrupar todas as aulas atrav√©s do Object.assign. Cada chave desse novo objeto ser√° uma aula, sendo essas chaves: lesson1, lesson2 e lesson3. Ao executar o comando console.log(allLessons), a sa√≠da dever√° ser a seguinte:
Copiar
console.log(allLessons);
/*
{
  lesson1:
   { materia: 'Matem√°tica',
     numeroEstudantes: 20,
     professor: 'Maria Clara',
     turno: 'manh√£' },
  lesson2:
   { materia: 'Hist√≥ria',
     numeroEstudantes: 20,
     professor: 'Carlos',
     turno: 'noite' },
  lesson3:
   { materia: 'Matem√°tica',
     numeroEstudantes: 10,
     professor: 'Maria Clara',
     turno: 'noite' }
};
*/
Usando o objeto criado no exerc√≠cio 5, crie uma fun√ß√£o que retorne o n√∫mero total de estudantes em todas as aulas.
Crie uma fun√ß√£o que obtenha o valor da chave de acordo com o seu √≠ndice no objeto. Por exemplo:
Copiar
console.log(getValueByNumber(lesson1, 0));
// Output: 'Mat√©matica'
Crie uma fun√ß√£o que verifique se o par (chave / valor) existe na fun√ß√£o. Essa fun√ß√£o deve possuir tr√™s par√¢metros, sendo eles: o objeto, o nome da chave e o valor da chave. Exemplo:
Copiar
console.log(verifyPair(lesson3, 'turno', 'noite'));
// Output: true,
console.log(verifyPair(lesson3, 'materia', 'Maria Clara'));
// Output: false




B√¥nus
üöÄ Crie uma fun√ß√£o para contar quantos estudantes assistiram √†s aulas de Matem√°tica. Use o objeto criado no exerc√≠cio 5.
üöÄ Crie uma fun√ß√£o que dever√° retornar um objeto que representa o relat√≥rio do professor ou professora, as aulas que ele ou ela ministrou e o n√∫mero total de estudantes. Use o objeto criado no exerc√≠cio 5:
Copiar
console.log(createReport(allLessons, 'Maria Clara'))
/* {
  professor: 'Maria Clara',
  aulas: [ 'Matem√°tica', 'Matem√°tica' ],
  estudantes: 30
} */
