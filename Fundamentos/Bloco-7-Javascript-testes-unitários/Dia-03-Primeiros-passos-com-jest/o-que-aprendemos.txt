O que vamos aprender?
Voc√™ aprender√° sobre testes unit√°rios e tamb√©m sobre como testar em pequenos passos.
J√° o conceito de testar em pequenos passos fala sobre como orientar nosso desenvolvimento com base nos testes!
Para isso, voc√™ utilizar√° o Jest , um framework de testes para JavaScript desenvolvido pelo Facebook.



Voc√™ ser√° capaz de:
Entender o que s√£o e para que servem testes unit√°rios;
Aplicar o conceito de TDD, ou seja, o desenvolvimento orientado a testes;
Criar testes unit√°rios a partir do framework Jest.



Por que isso √© importante?
O desenvolvimento de software n√£o √© algo simples e cada engrenagem de uma aplica√ß√£o pode ser muito delicada. S√£o muitas vari√°veis que voc√™ deve se preocupar, a cada vez que implementa alguma modifica√ß√£o, como o desempenho, disposi√ß√£o dos componentes e etc. Seria muito infeliz ter que checar cada retorno do seu c√≥digo antes de toda vez que for fazer um commit. Al√©m disso, n√£o seria confi√°vel, pois seres humanos cometem falhas. Por isso, programe a m√°quina para trabalhar a seu favor üòâ.
Quando voc√™ pensa em comprar um carro, espera que ele tenha passado por diversos testes para garantir a sua seguran√ßa. Qualquer pessoa deseja um produto de qualidade, por que ent√£o n√£o criar aplica√ß√µes web com esse padr√£o tamb√©m? Afinal, a √∫nica consequ√™ncia ser√° reduzir defeitos e aumentar o valor do sistema.
E o mais importante: o mindset que se desenvolve ao escrever testes para uma aplica√ß√£o for√ßa quem desenvolve a imaginar e prever os fluxos que uma pessoa pode percorrer ao usar a sua aplica√ß√£o. Isso diminui as chances de gerar bugs ou escrever c√≥digos que precisar√£o ser refeitos depois.
Testes s√£o fundamentais e tem um grande valor no dia a dia de quem desenvolve. At√© o curso acabar, espera-se que a ideia de fazer um c√≥digo sem test√°-lo seja inc√¥moda. Voc√™ ir√° se formar com um mindset orientado a testes!




Conte√∫dos
Na ind√∫stria, qualidade √© algo perseguido h√° tempos! Diversas metodologias surgiram, sempre com o objetivo de melhorar a qualidade e ao mesmo tempo reduzir custo, pois a consequ√™ncia de um defeito pode ser desastroso, n√£o s√≥ para as finan√ßas, mas tamb√©m para o nome da empresa.
Basicamente, existem tr√™s dimens√µes de qualidade que precisam ser consideradas:
Confian√ßa: O sistema √© resistente a falhas durante a execu√ß√£o, isto √©, n√£o entra em loop, n√£o interrompe a execu√ß√£o por falta de recursos.
Funcionalidade: O sistema se comporta conforme o que foi definido em seus requisitos.
Performance: O sistema tem um tempo de resposta adequado e aceit√°vel, mesmo quando submetido a um volume de processamento pr√≥ximo de situa√ß√µes reais ou de pico.
E, para atender a essas tr√™s dimens√µes, a pessoa que programa tem uma nova tarefa: desenvolver com foco em qualidade.



Testes unit√°rios: uma analogia ao rel√≥gio
Digamos que voc√™, como pessoa desenvolvedora de software em um universo paralelo, seja uma pessoa relojoeira. A sua responsabilidade √© confeccionar rel√≥gios de qualidade desde o zero, construindo desde as menores pe√ßas. Ao confeccionar as centenas de engrenagens, molas e parafusos que ir√£o constituir seu rel√≥gio, voc√™ deve seguir especifica√ß√µes.
Cada unidade de engrenagens, molas e parafusos, ao serem confeccionadas, s√£o testadas individualmente, medidas e verificadas, para garantir que ir√£o funcionar conforme o esperado. Engrenagens devem suavemente girar, molas devem ter uma certa resist√™ncia, e parafusos devem ter diferentes espessuras e tamanhos, e por a√≠ vai.
Como voc√™ poderia ter certeza de que cada pecinha do rel√≥gio est√° cumprindo sua devida fun√ß√£o?
Com essa provoca√ß√£o, introduziremos voc√™ aos testes unit√°rios, que tem a fun√ß√£o de validar o comportamento do nosso c√≥digo de forma s√≥lida e precisa. Testes unit√°rios s√£o por√ß√µes de c√≥digo respons√°veis por validar o comportamento de unidades funcionais de c√≥digo.
Nesse contexto, entende-se como unidade funcional qualquer por√ß√£o de c√≥digo que, atrav√©s de algum est√≠mulo, seja capaz de gerar um comportamento esperado. Isso inclui fun√ß√µes, propriedades, construtores... tudo que, de alguma maneira, processe um comportamento de valor e que voc√™ deseja garantir que, apesar das altera√ß√µes em n√≠vel de c√≥digo, o comportamento siga sendo o mesmo.
Portanto, os testes unit√°rios, assim como qualquer teste automatizado, permitem uma melhor manuten√ß√£o do seu c√≥digo. Eles n√£o servem somente para verificar se uma fun√ß√£o espec√≠fica est√° funcionando, mas tamb√©m para garantir que sua aplica√ß√£o continue funcionando ap√≥s alguma altera√ß√£o. Sendo assim, √© interessante pensar neles como um investimento de tempo para o futuro.



Testando em pequenos passos
O TDD: Test Driven Development, em tradu√ß√£o livre, o desenvolvimento orientado a testes, √© uma t√©cnica de desenvolvimento que, em certos cen√°rios, favorece a produtividade e a escrita de c√≥digos confi√°veis. Essa t√©cnica √© interessante porque ela ajuda a criar uma mente programadora orientada a testes, ainda que nem sempre escrever testes antes de escrever funcionalidades seja a pr√°tica mais adequada.
O TDD √© muito importante como exerc√≠cio e para determinados tipos de projetos, mas est√° longe de ser um consenso na comunidade programadora como pr√°tica fundamental para 100% dos casos. √â importante que essa vis√£o cr√≠tica fique bem clara.
Tendo isso em mente hoje voc√™ vai aprender e praticar o TDD, mas o conhecimento a ser absorvido √© "como testar bem uma aplica√ß√£o, de forma eficaz e produtiva" e "como ter um mindset orientado a testes", e n√£o especificamente como a metodologia funciona.
Com muita pr√°tica e experi√™ncia, voc√™ ir√° desenvolver a intui√ß√£o necess√°ria para avaliar se o TDD √© a melhor abordagem para testar a sua aplica√ß√£o. Um exemplo interessante que o TDD pode ser bastante √∫til √© no teste de fun√ß√µes puras.
O desenvolvimento orientado a testes √© um processo c√≠clico que pode ser descrito em tr√™s etapas, como ilustrado abaixo. O princ√≠pio b√°sico do TDD √© fazer testes pequenos.

Ciclo TDD - inspirado no artigo de Kent Dodds dispon√≠vel nos recursos adicionais
Destrinchando cada etapa, o TDD consiste em:
Escrever um teste que cubra a fun√ß√£o que voc√™ pretende implementar antes mesmo de execut√°-la. Este teste ir√° falhar - afinal, a sua fun√ß√£o ainda n√£o foi declarada. Voc√™ pode come√ßar do teste mais elementar poss√≠vel para esse cen√°rio, como verificar se a fun√ß√£o que voc√™ ir√° criar existe.
Implementar apenas o necess√°rio para que o teste passe. No caso do exemplo anterior, voc√™ s√≥ precisaria declarar a fun√ß√£o para passar o teste.
Refatorar o c√≥digo para que ele esteja bem escrito e f√°cil de se entender. O pulo do gato nessa etapa √© que voc√™ tem um teste j√° implementado que ir√° falhar caso voc√™ quebre algo ao refatorar o seu c√≥digo.
Repetir! Afinal de contas, o desenvolvimento orientado a testes √© um ciclo. Volte a etapa 1 e repita esse processo at√© que todas as funcionalidades da sua fun√ß√£o sejam implementadas.
Com muita pr√°tica e experi√™ncia, voc√™ ir√° desenvolver a intui√ß√£o necess√°ria para avaliar se o TDD √© a melhor abordagem para testar a sua aplica√ß√£o. Um exemplo interessante onde o TDD pode ser bastante √∫til √© no teste de fun√ß√µes puras, uma vez que elas s√£o mais f√°ceis de testar e n√£o causam efeitos colaterais.
E o que s√£o fun√ß√µes puras? S√£o fun√ß√µes cujo resultado √© determinado puramente pelos argumentos passados a elas, ou seja, o retorno √© sempre previs√≠vel. Por exemplo, uma fun√ß√£o que retorna o dobro do valor recebido como argumento. Ent√£o, sempre que o argumento for 2, o valor de retorno ser√° 4.
Dessa forma se a fun√ß√£o acessa ou modifica qualquer coisa que n√£o tenha sido passada como par√¢metro a ela, √© ent√£o uma fun√ß√£o impura.
Exemplos de fun√ß√µes impuras:
Copiar
var count = 0;

function increaseCount(val) {
    count += val;
}

function getSomething() {
    return count > 0;
}
A fun√ß√£o increaseCount n√£o √© pura, pois, apesar de usar o valor do par√¢metro, o seu retorno est√° modificando uma vari√°vel que est√° fora do seu escopo. A fun√ß√£o getSomething n√£o √© pura, pois acessa a vari√°vel que n√£o est√° em seu escopo.
Al√©m de ser √∫til para testar fun√ß√µes puras, outro exemplo pr√°tico em que o desenvolvimento orientado a testes pode ser √∫til √© consertar bugs. Os testes ajudam a quebrar problemas complexos em partes menores que podem ser analisadas mais facilmente. Assim, voc√™ poder√° focar em uma regra de neg√≥cio espec√≠fica sem medo de quebrar alguma outra funcionalidade.




NodeJS Assert
Para come√ßar, conhe√ßa um pouco sobre o NodeJS Assert.
O m√≥dulo Assert √© uma ferramenta que testa express√µes. Esse m√≥dulo j√° vem instalado com o NodeJS. Podemos entender o assert como sendo uma express√£o booleana que ser√° sempre true, a menos que haja uma falha.
Abaixo temos um exemplo de como podemos fazer um teste simples com assert:
Copiar
const assert = require('assert'); // Sintaxe para incluir o m√≥dulo assert

assert.strictEqual(50, 50); // Sem erros: 50 === 50
assert.strictEqual(50, 70); // AssertionError: 50 !== 70
Para o seu desenvolvimento durante o curso, ser√° necess√°rio o uso de ferramentas mais robustas, como o Jest, que voc√™ aprender√° na aula de hoje. Mas, caso tenha se interessado, voc√™ pode consultar mais sobre o NodeJS Assert aqui na documenta√ß√£o.




Introdu√ß√£o ao Jest
"Por que precisamos de um framework? N√£o d√° pra escrever todos os testes somente com asserts simples? "
Em teoria, sim. Mas √† medida que suas aplica√ß√µes se tornam maiores e mais complexas, esse processo torna-se invi√°vel pelos motivos abaixo:
Sua aplica√ß√£o ter√° v√°rias fun√ß√µes, provavelmente distribu√≠das por v√°rios arquivos. Colocar todos os testes em um √∫nico arquivo torna-se impratic√°vel rapidamente. N√£o √© poss√≠vel saber onde come√ßam e onde terminam os testes de uma fun√ß√£o. Mesmo em uma fun√ß√£o mais complexa, voc√™ pode querer separar e agrupar testes relacionados;
Node.js s√≥ executa um arquivo por vez, com o comando node <nome_do_arquivo>. Se h√° v√°rios arquivos de teste, √© preciso executar um por vez ou escrever um script shell para executar todos os arquivos;
Voc√™ sempre precisa executar todos os testes de um arquivo. N√£o h√° como executar apenas um subgrupo dos testes presentes no arquivo;
Sempre que um teste falha, a execu√ß√£o √© interrompida imediatamente. Isso dificulta saber se os testes posteriores est√£o corretos, necessitando garantir que todos os testes anteriores estejam corretos;
V√°rios testes podem requerer que os mesmos passos sejam executados antes ou ap√≥s a execu√ß√£o, resultando em muita duplica√ß√£o;
Para pular ou desabilitar um teste falhando, √© preciso remov√™-lo ou coment√°-lo;
N√£o h√° informa√ß√µes sobre a cobertura de testes. Ou seja, quais partes do c√≥digo est√£o sendo estressadas pelos testes e quais n√£o est√£o;
Para o mercado de trabalho, o assert √© insuficiente. Normalmente os programas est√£o sempre evoluindo e ganhando novas features e, por conta disso, surgiu a necessidade de criar uma su√≠te de testes mais robusta, leg√≠vel e de f√°cil manuten√ß√£o.
Um framework de testes apresenta ferramentas para eliminar ou mitigar esses problemas. Existem v√°rias ferramentas semelhantes, como Jest, Mocha e Jasmine. Entre eles, Jest se destaca por alguns motivos:
√â f√°cil de instalar e requer zero configura√ß√£o, como voc√™ ver√° em breve;
√â r√°pido. O time de engenharia do Airbnb conseguiu diminuir o tempo de execu√ß√£o de sua su√≠te de testes de 12 para 4 minutos ao trocar Mocha por Jest;
Se integra muito bem com React. De fato, o Jest j√° vem instalado e configurado com o React. N√£o se preocupe se voc√™ n√£o souber o que √© o React, voc√™ aprender√° sobre ele em Front-end.
Chega de teoria. Vamos botar a m√£o na massa e come√ßar a escrever testes com Jest.




Instalando o Jest
Para realizar a instala√ß√£o do Jest, siga as instru√ß√µes do v√≠deo ou do texto logo abaixo.

Para come√ßar a instalar o Jest, voc√™ precisa ter o npm instalado e funcionando corretamente, abaixo temos um passo a passo, feito para Linux, sabendo disso, ent√£o v√° ao seu terminal e digite:
Copiar
npm -v
Se ele te mostrar um n√∫mero de vers√£o (por exemplo, 6.14.4) est√° tudo certo, voc√™ pode pular os comandos deste passo. Caso ele retorne um erro dizendo que n√£o encontrou o comando voc√™ dever√° executar a instala√ß√£o do npm, descrita abaixo:
a. Primeiro vamos atualizar a nossa lista de reposit√≥rios:
Copiar
sudo apt update
b. Agora com a lista de reposit√≥rios atualizada, vamos instalar o npm. Lembre-se que ao instalar com apt, voc√™ pode utilizar o comando de qualquer local, e em todas as pr√≥ximas vezes voc√™ n√£o dever√° reinstalar, s√≥ execute esse passo caso n√£o tenha o npm instalado ainda.
Copiar
sudo apt install npm
Agora vamos simular a cria√ß√£o de um projeto que utilizar√° a biblioteca do Jest para os testes. Com o npm devidamente instalado e verificado, crie uma pasta e entre nesta nova pasta que voc√™ criou.
Copiar
mkdir my_new_project
cd my_new_project
Obs: √â importante criar esta nova pasta para cada um dos seus projetos, pois al√©m de ficar mais organizado, voc√™ vai evitar que as configura√ß√µes de um projeto interfiram com outro, visto que o processo de instala√ß√£o ir√° criar arquivos e pastas.
a. Ap√≥s entrar na pasta, precisamos criar um novo package.json para o seu novo projeto.
O package.json √© respons√°vel por armazenar e descrever diversas informa√ß√µes de seu projeto, como a vers√£o do node e do npm utilizadas, url do reposit√≥rio, vers√£o do projeto, depend√™ncias de produ√ß√£o e de desenvolvimento.
Para criar o package.json no seu projeto execute em seu terminal o comando abaixo:
Copiar
npm init -y
Voc√™ ter√° o seguinte retorno:
Copiar
Wrote to /home/cleyton/Documents/meuApp/package.json:

{
  "name": "meuApp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
Vamos analisar algumas das informa√ß√µes desse objeto:
A primeira chave "name", por padr√£o, ter√° o mesmo nome do diret√≥rio em que voc√™ criou o arquivo package.json. Ele representa o nome do seu projeto;
A vers√£o atual do projeto √© "1.0.0", ou seja a primeira vers√£o;
Podemos adicionar alguma descri√ß√£o na chave "description";
A chave "scripts" define um conjunto de scripts Node que podem ser executados.
N√£o se preocupe se essas informa√ß√µes ainda n√£o fizerem sentido pra voc√™. Futuramente vamos retornar e explicar o que cada um desses dados representa. No momento, √© importante saber apenas que o package.json √© um objeto que armazena uma s√©rie de informa√ß√µes sobre o seu projeto.
b. Agora precisamos editar nosso package.json. Voc√™ deve ter observado que na chave "test" em "script" temos a seguinte informa√ß√£o: "test": "echo \"Error: no test specified\" && exit 1". Isso significa que a nossa aplica√ß√£o ainda n√£o possui um script que defina como lidar com testes. Ent√£o vamos trocar essa informa√ß√£o por "test": "jest". N√£o se esque√ßa de salvar o arquivo. Ap√≥s a altera√ß√£o teremos algo parecido com:
Copiar
{
  "name": "meuApp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
 }
Por fim, vamos instalar o Jest, dentro da pasta que voc√™ criou no passo 3, executando o seguinte comando no terminal:
Copiar
npm install --save-dev jest
Ap√≥s rodar esse comando, vamos ver uma altera√ß√£o importante que ocorreu no arquivo package.json. Para isso vamos abrir a pasta que voc√™ criou no seu VsCode com o comando abaixo:
Copiar
code .
A sua pasta agora cont√©m dois arquivos, o package.json e o package-lock.json e um novo diret√≥rio chamado node modules, estes √∫ltimos dois foram criados ap√≥s voc√™ executar o comando npm install --save-dev jest. Ao abrirmos o arquivo package.json, veremos algo do tipo:
Copiar
{
  "name": "meuApp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "jest": "^27.0.6"
  }
}
Perceba que agora nosso arquivo package.json possui uma nova chave, "devDependencies" contendo o jest e a vers√£o que est√° sendo utilizada neste projeto.
Agora, o que √© "devDependencies"? O "devDependencies" define os pacotes instalados no projeto como depend√™ncias de desenvolvimento. Ou seja, s√£o pacotes que ser√£o importantes apenas para o desenvolvimento do projeto. Existe tamb√©m uma chave chamada "dependencies", que, diferente da primeira, lista os pacotes instalados como depend√™ncias de produ√ß√£o.
E os outros dois?
O node_modules √© a pasta que guarda todos os arquivos baixados das depend√™ncias instaladas.
O package-lock.json √© um arquivo que ‚Äútrava‚Äù as vers√µes das depend√™ncias. Quando outra pessoa executar npm install ou npm i para baixar as depend√™ncias, este arquivo garante que ser√£o instaladas as mesmas vers√µes para todo mundo.
Aqui vale ressaltar mais um ponto. Lembra do arquivo .gitignore que vimos anteriormente? O .gitignore √© utilizado para especificar arquivos ou diret√≥rios que n√£o queremos que sejam rastreados pelo git.
√â considerado uma boa pr√°tica no desenvolvimento, inserir a pasta node_modules em um arquivo .gitignore em todo projeto que voc√™ criar. Isso porque essa pasta cont√©m centenas de arquivos e o processo de adicionar o seu projeto a um reposit√≥rio remoto pode acarretar em mais tempo se voc√™ incluir essa pasta. Al√©m disso, suponha que algu√©m v√° realizar o clone do seu projeto, o processo tamb√©m demoraria muito mais, visto que essa pasta cont√©m muitos arquivos, mas pera a√≠, essa pasta n√£o √© importante porque guarda todos os arquivos das depend√™ncias instaladas? Sim, voc√™ tem raz√£o, e √© a√≠ que os arquivos package.json e package-lock.json entram em cena. Ao clonar um projeto que cont√©m depend√™ncias a serem instaladas, basta rodar dentro da pasta o comando npm install e todas as depend√™ncias e vers√µes listadas nestes dois arquivos .json ser√£o instaladas, criando a pasta node_modules.
Agora que voc√™ j√° est√° com tudo pronto, vamos pro conte√∫do de testes em Jest que est√° maravilhoso!
Para testar sua instala√ß√£o, vamos criar um arquivo chamado sum.test.js e colar o c√≥digo abaixo dentro dele:
Copiar
const sum = (a, b) => a + b;

test('sums two values', () => {
  expect(sum(2, 3)).toEqual(5);
});
Depois disso, vamos at√© o terminal digitar npm test, se voc√™ receber uma resposta parecida com a resposta abaixo, tudo certo com a instala√ß√£o!

teste de instala√ß√£o
Caso voc√™ n√£o veja a tela acima, tente rever os passos, observe se voc√™ entrou na nova pasta que criou, verifique se n√£o h√° a pasta node_modules j√° instalada na sua home ou pasta raiz, averigue o arquivo exemplo e o nome do arquivo, caso ele n√£o tenha o .test ou .spec no nome, o Jest n√£o tenta ler o arquivo, porque n√£o reconhece como um arquivo de teste, isso ser√° explicado melhor durante o conte√∫do de hoje.
Caso voc√™ queira ver na pr√°tica como √© esse processo, assista ao v√≠deo abaixo:





Instalando o Jest
Para realizar a instala√ß√£o do Jest, siga as instru√ß√µes do v√≠deo ou do texto logo abaixo.

Para come√ßar a instalar o Jest, voc√™ precisa ter o npm instalado e funcionando corretamente, abaixo temos um passo a passo, feito para Linux, sabendo disso, ent√£o v√° ao seu terminal e digite:
Copiar
npm -v
Se ele te mostrar um n√∫mero de vers√£o (por exemplo, 6.14.4) est√° tudo certo, voc√™ pode pular os comandos deste passo. Caso ele retorne um erro dizendo que n√£o encontrou o comando voc√™ dever√° executar a instala√ß√£o do npm, descrita abaixo:
a. Primeiro vamos atualizar a nossa lista de reposit√≥rios:
Copiar
sudo apt update
b. Agora com a lista de reposit√≥rios atualizada, vamos instalar o npm. Lembre-se que ao instalar com apt, voc√™ pode utilizar o comando de qualquer local, e em todas as pr√≥ximas vezes voc√™ n√£o dever√° reinstalar, s√≥ execute esse passo caso n√£o tenha o npm instalado ainda.
Copiar
sudo apt install npm
Agora vamos simular a cria√ß√£o de um projeto que utilizar√° a biblioteca do Jest para os testes. Com o npm devidamente instalado e verificado, crie uma pasta e entre nesta nova pasta que voc√™ criou.
Copiar
mkdir my_new_project
cd my_new_project
Obs: √â importante criar esta nova pasta para cada um dos seus projetos, pois al√©m de ficar mais organizado, voc√™ vai evitar que as configura√ß√µes de um projeto interfiram com outro, visto que o processo de instala√ß√£o ir√° criar arquivos e pastas.
a. Ap√≥s entrar na pasta, precisamos criar um novo package.json para o seu novo projeto.
O package.json √© respons√°vel por armazenar e descrever diversas informa√ß√µes de seu projeto, como a vers√£o do node e do npm utilizadas, url do reposit√≥rio, vers√£o do projeto, depend√™ncias de produ√ß√£o e de desenvolvimento.
Para criar o package.json no seu projeto execute em seu terminal o comando abaixo:
Copiar
npm init -y
Voc√™ ter√° o seguinte retorno:
Copiar
Wrote to /home/cleyton/Documents/meuApp/package.json:

{
  "name": "meuApp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
Vamos analisar algumas das informa√ß√µes desse objeto:
A primeira chave "name", por padr√£o, ter√° o mesmo nome do diret√≥rio em que voc√™ criou o arquivo package.json. Ele representa o nome do seu projeto;
A vers√£o atual do projeto √© "1.0.0", ou seja a primeira vers√£o;
Podemos adicionar alguma descri√ß√£o na chave "description";
A chave "scripts" define um conjunto de scripts Node que podem ser executados.
N√£o se preocupe se essas informa√ß√µes ainda n√£o fizerem sentido pra voc√™. Futuramente vamos retornar e explicar o que cada um desses dados representa. No momento, √© importante saber apenas que o package.json √© um objeto que armazena uma s√©rie de informa√ß√µes sobre o seu projeto.
b. Agora precisamos editar nosso package.json. Voc√™ deve ter observado que na chave "test" em "script" temos a seguinte informa√ß√£o: "test": "echo \"Error: no test specified\" && exit 1". Isso significa que a nossa aplica√ß√£o ainda n√£o possui um script que defina como lidar com testes. Ent√£o vamos trocar essa informa√ß√£o por "test": "jest". N√£o se esque√ßa de salvar o arquivo. Ap√≥s a altera√ß√£o teremos algo parecido com:
Copiar
{
  "name": "meuApp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
 }
Por fim, vamos instalar o Jest, dentro da pasta que voc√™ criou no passo 3, executando o seguinte comando no terminal:
Copiar
npm install --save-dev jest
Ap√≥s rodar esse comando, vamos ver uma altera√ß√£o importante que ocorreu no arquivo package.json. Para isso vamos abrir a pasta que voc√™ criou no seu VsCode com o comando abaixo:
Copiar
code .
A sua pasta agora cont√©m dois arquivos, o package.json e o package-lock.json e um novo diret√≥rio chamado node modules, estes √∫ltimos dois foram criados ap√≥s voc√™ executar o comando npm install --save-dev jest. Ao abrirmos o arquivo package.json, veremos algo do tipo:
Copiar
{
  "name": "meuApp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "jest": "^27.0.6"
  }
}
Perceba que agora nosso arquivo package.json possui uma nova chave, "devDependencies" contendo o jest e a vers√£o que est√° sendo utilizada neste projeto.
Agora, o que √© "devDependencies"? O "devDependencies" define os pacotes instalados no projeto como depend√™ncias de desenvolvimento. Ou seja, s√£o pacotes que ser√£o importantes apenas para o desenvolvimento do projeto. Existe tamb√©m uma chave chamada "dependencies", que, diferente da primeira, lista os pacotes instalados como depend√™ncias de produ√ß√£o.
E os outros dois?
O node_modules √© a pasta que guarda todos os arquivos baixados das depend√™ncias instaladas.
O package-lock.json √© um arquivo que ‚Äútrava‚Äù as vers√µes das depend√™ncias. Quando outra pessoa executar npm install ou npm i para baixar as depend√™ncias, este arquivo garante que ser√£o instaladas as mesmas vers√µes para todo mundo.
Aqui vale ressaltar mais um ponto. Lembra do arquivo .gitignore que vimos anteriormente? O .gitignore √© utilizado para especificar arquivos ou diret√≥rios que n√£o queremos que sejam rastreados pelo git.
√â considerado uma boa pr√°tica no desenvolvimento, inserir a pasta node_modules em um arquivo .gitignore em todo projeto que voc√™ criar. Isso porque essa pasta cont√©m centenas de arquivos e o processo de adicionar o seu projeto a um reposit√≥rio remoto pode acarretar em mais tempo se voc√™ incluir essa pasta. Al√©m disso, suponha que algu√©m v√° realizar o clone do seu projeto, o processo tamb√©m demoraria muito mais, visto que essa pasta cont√©m muitos arquivos, mas pera a√≠, essa pasta n√£o √© importante porque guarda todos os arquivos das depend√™ncias instaladas? Sim, voc√™ tem raz√£o, e √© a√≠ que os arquivos package.json e package-lock.json entram em cena. Ao clonar um projeto que cont√©m depend√™ncias a serem instaladas, basta rodar dentro da pasta o comando npm install e todas as depend√™ncias e vers√µes listadas nestes dois arquivos .json ser√£o instaladas, criando a pasta node_modules.
Agora que voc√™ j√° est√° com tudo pronto, vamos pro conte√∫do de testes em Jest que est√° maravilhoso!
Para testar sua instala√ß√£o, vamos criar um arquivo chamado sum.test.js e colar o c√≥digo abaixo dentro dele:
Copiar
const sum = (a, b) => a + b;

test('sums two values', () => {
  expect(sum(2, 3)).toEqual(5);
});
Depois disso, vamos at√© o terminal digitar npm test, se voc√™ receber uma resposta parecida com a resposta abaixo, tudo certo com a instala√ß√£o!

teste de instala√ß√£o
Caso voc√™ n√£o veja a tela acima, tente rever os passos, observe se voc√™ entrou na nova pasta que criou, verifique se n√£o h√° a pasta node_modules j√° instalada na sua home ou pasta raiz, averigue o arquivo exemplo e o nome do arquivo, caso ele n√£o tenha o .test ou .spec no nome, o Jest n√£o tenta ler o arquivo, porque n√£o reconhece como um arquivo de teste, isso ser√° explicado melhor durante o conte√∫do de hoje.
Caso voc√™ queira ver na pr√°tica como √© esse processo, assista ao v√≠deo abaixo:




Escrevendo testes
Escrever testes em Jest √© muito simples, como voc√™ deve ter percebido enquanto lia o artigo anterior. Tudo que √© necess√°rio √© utilizar a fun√ß√£o test. A fun√ß√£o it √© um alias para test, ou seja, ambas se referem √† mesma fun√ß√£o e voc√™ pode usar qualquer uma delas. Essas fun√ß√µes, por serem globais, ficam automaticamente dispon√≠veis nos seus arquivos uma vez que o Jest √© instalado.
A fun√ß√£o test espera tr√™s argumentos. O primeiro argumento √© o nome do teste. Esse nome identifica o teste e √© tamb√©m o texto que aparecer√° quando os testes forem executados. O segundo argumento √© uma fun√ß√£o contendo suas expectations. Em outras palavras, √© dentro dessa fun√ß√£o que voc√™ far√° os testes propriamente ditos. O terceiro argumento (opcional) √© um timeout, indicando quanto tempo o Jest deve esperar que o teste execute antes de abort√°-lo.
Para entender melhor, veja o c√≥digo abaixo:
Copiar
// sum.js
const sum = (a, b) => a + b;

test('sums two values', () => {
  expect(sum(2, 3)).toEqual(5);
});
Neste exemplo, tanto a implementa√ß√£o quanto os testes da fun√ß√£o est√£o no mesmo arquivo. Na pr√°tica, por√©m, eles ficar√£o separados. Jest procura por arquivos com as extens√µes .js, .jsx, .ts e .tsx dentro de uma pasta com o nome __tests__, ou arquivos com o sufixo .test ou .spec. √â comum que o arquivo de teste tenha o mesmo nome e fique na mesma pasta do arquivo que est√° sendo testado, acrescido da sufixo .test.js:
Copiar
// sum.js
const sum = (a, b) => a + b;

module.exports = sum;
Copiar
// sum.test.js
const sum = require('./sum');

test('sums two values', () => {
  expect(sum(2, 3)).toBe(5);
});
A linha module.exports = sum exporta a fun√ß√£o sum no primeiro arquivo para que possa ser utilizada em outros m√≥dulos. No segundo arquivo, utilizamos require('./sum') para importar a fun√ß√£o sum. Veja a se√ß√£o de recursos adicionais para entender mais sobre como importar e exportar m√≥dulos em Node.js.
Agora que voc√™ j√° viu um teste simples de jest em funcionamento, que tal praticar com mais este pr√≥ximo exemplo? N√£o se preocupe em entender como os testes est√£o estruturados neste exemplo. O objetivo aqui √© apenas mostrar o quanto trabalhar com a biblioteca Jest √© mais simples.
Crie um arquivo com o nome 'loginValidation.js' e dentro dele copie e cole o seguinte c√≥digo:
Copiar
// loginValidation.js
const greetingMessage = (user) => {
  return `Hello, ${user}! Que bom ter voc√™ de volta`;
};

const loginErrorMessage = (user) => {
  return `Pessoa usu√°ria '${user}' n√£o encontrada, tente novamente!`;
};

const user = {
  userName: "Joana",
  password: 123456,
};

const verifyCredentials = ({ userName, password }) => {
  if (password === 123456 && userName === "Joana") {
    return greetingMessage(userName);
  } else {
    return loginErrorMessage(userName);
  }
};

const { userName, password } = user;

module.exports = { greetingMessage, loginErrorMessage, verifyCredentials }
Vamos primeiro entender as fun√ß√µes que est√£o implementadas no arquivo loginValidation.js. Neste arquivo encontram-se tr√™s fun√ß√µes para simular uma situa√ß√£o de login. A fun√ß√£o verifyCredentials faz uma valida√ß√£o simples se a pessoa usu√°ria e a senha recebidas como argumento s√£o estritamente iguais as chaves userName e password contidas no objeto user. Se essa verifica√ß√£o retornar true a fun√ß√£o verifyCredentials vai chamar a fun√ß√£o greetingMessage, que por sua vez vai retornar uma frase de boas vindas com o nome da pessoa usu√°ria. J√° no caso da verifica√ß√£o retornar false, ou seja as credenciais inseridas n√£o corresponderem com as existentes no objeto, a fun√ß√£o verifyCredentials vai chamar a fun√ß√£o loginErrorMessage, que ir√° por sua vez retornar um erro.
Agora, crie outro arquivo no mesmo diret√≥rio com o nome 'loginValidation.test.js' e dentro dele copie e cole o c√≥digo abaixo:
Copiar
// loginValidation.test.js
const {
  greetingMessage,
  loginErrorMessage,
  verifyCredentials,
} = require("./loginValidation.js");

describe("a fun√ß√£o verifyCredentials()", () => {

  it("verifyCredentials() calls the correct function depending on the user and password input", () => {

    const user = {
      userName: 'Bob',
      password: 123456,
    };

    const { userName, password } = user;

    expect(verifyCredentials({ userName, password })).toBe(
      "Hello, Joana! Que bom ter voc√™ de volta"
    );
  });

  it("greetingMessage() returns a message in the format: `Hello, ${user}! Que bom ter voc√™ de volta`", () => {
    expect(greetingMessage("Lucas")).toBe(
      "Hello, Lucas! Que bom ter voc√™ de volta"
    );
  });

  it("loginErrorMessage() returns a message in the format: `Pessoa usu√°ria '${user}' n√£o encontrada, tente novamente!`", () => {
    expect(loginErrorMessage("Bob")).toBe(
      "Pessoa usu√°ria 'Bob' n√£o encontrada, tente novamente!"
    );
  });
});
Execute no seu terminal o comando npm test e veja o que acontece. Ao rodar o teste voc√™ receber√° a mensagem que um dos testes falhou, como na imagem abaixo:

Observe que, como dito anteriormente, mesmo existindo um teste com erro, os outros testes foram executados normalmente. Al√©m disso, o log do erro gerado pelo jest te possibilita identificar rapidamente onde foi que ocorreu o erro, uma vez que √© exibida a mensagem que est√° contida no teste em quest√£o. Neste caso o erro ocorreu no teste contendo a descri√ß√£o "verifyCredentials() calls the correct function depending on the user and password input", como voc√™ pode ver aqui:

Outro ponto positivo da utiliza√ß√£o do Jest para fazer nossos testes √© que ele traz uma mensagem contendo um diff, ou seja, o que era esperado de ocorrer no teste e o que de fato aconteceu. Isso nos ajuda a entender mais rapidamente onde est√° o erro. Neste exemplo o teste esperava receber como valor um objeto contendo uma pessoa usu√°ria com o nome "Joana", mas ao inv√©s disso recebeu "Bob".
Sensacional, n√£o √© mesmo? Ent√£o bora pro conte√∫do que na sequ√™ncia vamos explicar o que s√£o os expect e os matchers e como eles funcionam.




O bloco describe
A fun√ß√£o describe cria um bloco para agrupar v√°rios testes. Isso √© √∫til para melhorar a organiza√ß√£o dos seus testes. Voc√™ pode utilizar describe, por exemplo, para separar testes de fun√ß√µes diferentes em um mesmo arquivo, ou para agrupar testes relacionados dentro de uma fun√ß√£o complexa que requer muitos testes. √â poss√≠vel aninhar blocos describe arbitrariamente. Dentro de cada bloco, qualquer declara√ß√£o de vari√°veis ou fun√ß√µes √© local a este bloco. Leia os exemplos na documenta√ß√£o do Jest para fixar.



Um pouco de m√£o na massa
At√© agora voc√™ viu muita teoria e documenta√ß√£o. Assista aos dois v√≠deos abaixo para ver Jest sendo usado na pr√°tica.





Cobertura de testes
Como saber se os testes que voc√™ escreveu est√£o testando (ou "cobrindo") todo o c√≥digo-fonte que foi escrito? Para isso usaremos a cobertura de testes.

Ap√≥s escrever uma quantidade de testes, voc√™ pode rodar a cobertura de testes atrav√©s do comando:
Copiar
npm test -- --coverage
Este comando faz um levantamento de quanto do c√≥digo est√° sendo coberto pelos testes escritos. Ap√≥s executar o comando, voc√™ deve receber como retorno uma tabela similar √† tabela abaixo:

A partir da tabela, voc√™ tem informa√ß√µes sobre a quantidade de testes que est√° coberta por testes e como completar a cobertura desenvolvendo testes para a parte que ainda n√£o est√° coberta. As colunas da tabela trazem as seguintes informa√ß√µes:
Files: Lista os arquivos testados pelo jest.
% Stmts: Exibe a porcentagem de declara√ß√µes (statements) cobertas pelos testes.
% Branch: Exibe a porcentagem coberta dos diferentes caminhos por onde o c√≥digo pode seguir. Por exemplo, no caso de estruturas condicionais, como if, calcula se h√° teste para o caso verdadeiro e para o caso falso da condi√ß√£o.
% Funcs: Exibe a porcentagem das fun√ß√µes cobertas pelos testes.
% Lines: Exibe a porcentagem de linhas cobertas pelos testes.
Uncovered Line #s: Exibe os n√∫meros das linhas ainda n√£o cobertas pelos testes.
A partir da informa√ß√£o de quais linhas n√£o est√£o cobertas pelos testes √© poss√≠vel escrever os testes que faltam para cobrir todo o c√≥digo.
Caso queira uma visualiza√ß√£o mais amig√°vel, ap√≥s executar o comando para calcular a cobertura de testes, uma pasta "coverage" √© criada com as informa√ß√µes de cobertura de testes. Dentro dessa pasta, h√° uma pasta "lcov_report", que cont√©m um arquivo index.html com uma visualiza√ß√£o dos dados da tabela e ainda exibe o c√≥digo testado, marcando as linhas ainda n√£o cobertas pelos testes.

Importante: Uma cobertura de testes sobre 100% do c√≥digo-fonte n√£o quer dizer, necessariamente, que os seus testes s√£o suficientes para atestar o correto funcionamento do c√≥digo. Significa, apenas, que existem testes escritos para todas as linhas. Para fazer testes de forma completa, voc√™ precisa assegurar que seus testes cobrem as diferentes situa√ß√µes que podem ocorrer com seu c√≥digo.



Agora a pr√°tica
üöÄ Se liga nesse foguete!
Os exerc√≠cios destacados com üöÄ s√£o os fundamentais pra voc√™ ir bem no projeto! Todos os exerc√≠cios v√£o contribuir com sua forma√ß√£o mas fique de olho nesses! üëÄ
Praticando a implementa√ß√£o de testes
Voc√™ vai implementar v√°rios testes em contextos diferentes a fim de consolidar a mec√¢nica e tamb√©m a forma de pensar em testes.
Copie as fun√ß√µes j√° implementadas e desenvolva os testes. Separe as fun√ß√µes e os testes em arquivos diferentes para evitar qualquer tipo de problema.
Crie os arquivos com o respectivo nome da fun√ß√£o. Ex: sum.js e sum.test.js
Exporte a fun√ß√£o criada neste arquivo e importe no arquivo de teste. Ex:
module.exports = sum; no arquivo sum.js;
const sum = require('./sum.js'); no arquivo sum.test.js.
üëÄ Se o arquivo de teste n√£o estiver na mesma pasta da fun√ß√£o, √© importante especificar o caminho.
üöÄ 1 - A fun√ß√£o sum(a, b) retorna a soma do par√¢metro a com o b
Teste se o retorno de sum(4, 5) √© 9
Teste se o retorno de sum(0, 0) √© 0
Teste se a fun√ß√£o sum lan√ßa um erro quando os par√¢metros s√£o 4 e "5"(string 5)
Teste se a mensagem de erro √© "parameters must be numbers" quando realizar a chamada sum(4, "5")
Copiar
function sum(a, b) {
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new Error('parameters must be numbers');
  }

  return a + b;
}
üöÄ 2 - A fun√ß√£o myRemove(arr, item) recebe um array arr e retorna uma c√≥pia desse array sem o elemento item caso ele exista no array
Verifique se a chamada myRemove([1, 2, 3, 4], 3) retorna o array esperado
Verifique se a chamada myRemove([1, 2, 3, 4], 3) n√£o retorna o array [1, 2, 3, 4]
Verifique se a chamada myRemove([1, 2, 3, 4], 5) retorna o array esperado
Copiar
function myRemove(arr, item) {
  let newArr = [];
  for (let index = 0; index < arr.length; index += 1) {
    if (item !== arr[index]) {
      newArr.push(arr[index]);
    }
  }
  return newArr;
}

// implemente seus testes aqui
üöÄ 3 - A fun√ß√£o myFizzBuzz(num) recebe um n√∫mero num e retorna "fizzbuzz" se o n√∫mero for divis√≠vel por 3 e 5, retorna "fizz" se for divis√≠vel apenas por 3, retorna "buzz" se divis√≠vel apenas por 5, retorna o pr√≥prio n√∫mero caso n√£o seja divis√≠vel por 3 ou 5 e retorna false caso num n√£o seja um n√∫mero
Fa√ßa uma chamada com um n√∫mero divis√≠vel por 3 e 5 e verifique se o retorno √© o esperado
Fa√ßa uma chamada com um n√∫mero divis√≠vel por 3 e verifique se o retorno √© o esperado
Fa√ßa uma chamada com um n√∫mero divis√≠vel por 5 e verifique se o retorno √© o esperado
Fa√ßa uma chamada com um n√∫mero que n√£o √© divis√≠vel por 3 ou 5 e verifique se o retorno √© o esperado
Fa√ßa uma chamada com um par√¢metro que n√£o √© um n√∫mero e verifique se o retorno √© o esperado
Copiar
function myFizzBuzz(num) {
  if (typeof num !== 'number') return false;
  if (num % 3 === 0 && num % 5 === 0) return 'fizzbuzz';
  if (num % 3 === 0) return 'fizz';
  if (num % 5 === 0) return 'buzz';
  return num;
}

// implemente seus testes aqui
No Bloco 4 voc√™ desenvolveu um projeto para testar os seus conhecimentos em Javascript e l√≥gica de programa√ß√£o: o Playground functions. Nos exerc√≠cios a seguir, voc√™ ir√° trabalhar com os testes para algumas fun√ß√µes que voc√™ criou! Aproveite para refator√°-las e usar todos os recursos que j√° aprendemos at√© aqui, como as Higher Order Functions e as features do Javascript ES6.
üöÄ 4 - Para as fun√ß√µes encode e decode crie os seguintes testes em Jest:
Teste se encode e decode s√£o fun√ß√µes;
Para a fun√ß√£o encode teste se as vogais a, e, i, o, u s√£o convertidas em 1, 2, 3, 4 e 5, respectivamente;
Para a fun√ß√£o decode teste se os n√∫meros 1, 2, 3, 4 e 5 s√£o convertidos nas vogais a, e, i, o, u, respectivamente;
Teste se as demais letras/n√∫meros n√£o s√£o convertidos para cada caso;
Teste se a string que √© retornada pelas fun√ß√µes t√™m o mesmo n√∫mero de caracteres que a string passada como par√¢metro.
üöÄ 5 - A fun√ß√£o techList recebe como par√¢metros um array contendo uma lista de tecnologias e uma string com um nome. Para cada tecnologia no array a fun√ß√£o cria, em ordem alfab√©tica, um objeto com a seguinte estrutura:
Copiar
{
  tech: 'nomeTecnologia',
  name: name,
}
Implemente a fun√ß√£o techList a partir dos testes abaixo. Experimente refatorar a fun√ß√£o que voc√™ criou para esse projeto! √â importante nunca alterar os testes ou as vari√°veis j√° escritas no c√≥digo.
Copiar
const techList = require('./techList.js');

describe('Testa a fun√ß√£o techList', () => {
  it('Testa se a fun√ß√£o techList √© definida', () => {
    expect(techList).toBeDefined();
  });
  it('Testa se techList √© uma fun√ß√£o', () => {
    expect(typeof techList).toBe('function');
  });
  it('Lista com 5 tecnologias deve retornar uma lista de objetos ordenados', () => {
    expect(techList(['React', 'Jest', 'HTML', 'CSS', 'JavaScript'], 'Lucas')).toEqual([
      {
        tech: 'CSS',
        name: 'Lucas'
      },
      {
        tech: 'HTML',
        name: 'Lucas'
      },
      {
        tech: 'JavaScript',
        name: 'Lucas'
      },
      {
        tech: 'Jest',
        name: 'Lucas'
      },
      {
        tech: 'React',
        name: 'Lucas'
      }
    ]);
  });
  it('Lista com 0 tecnologias deve retornar uma mensagem de erro "Vazio!"', () => {
    expect(techList([], 'Lucas')).toBe('Vazio!');
  });
});

module.exports = techList;
üöÄ 6 - A fun√ß√£o hydrate recebe uma string no formato "numero bebida", e retorna a sugest√£o de quantos copos de √°gua voc√™ deve beber para se hidratar. Para cada bebida, deve-se tomar um copo de √°gua para n√£o ter ressaca. Exemplo:
Copiar
// string recebida
'1 cerveja'
// retorno da fun√ß√£o
'1 copo de √°gua'

// string recebida
'1 cerveja, 2 shots e 1 catuaba'
// retorno da fun√ß√£o
'4 copos de √°gua'

// string recebida
'2 caipirinhas'
// retorno da fun√ß√£o
'2 copos de √°gua'
Implemente a fun√ß√£o hydrate a partir dos testes abaixo. Experimente refatorar a fun√ß√£o que voc√™ criou para o projeto Playground Function! √â importante nunca alterar os testes ou as vari√°veis j√° escritas no c√≥digo.
Copiar
const hydrate = require('./hydrate.js');

describe('Testa a fun√ß√£o hydrate', () => {
  it('Testa se a fun√ß√£o hydrate √© definida', () => {
    expect(hydrate).toBeDefined();
  });
  it('Testa se hydrate √© uma fun√ß√£o', () => {
    expect(typeof hydrate).toBe('function');
  });
  it('Ao receber uma string retorne a sugest√£o de quantos copos de √°gua deve-se beber', () => {
    expect(hydrate('1 cerveja')).toBe('1 copo de √°gua');
    expect(hydrate('1 cacha√ßa, 5 cervejas e 1 copo de vinho')).toBe('7 copos de √°gua');
    expect(hydrate('2 shots de tequila, 2 cervejas e 1 corote')).toBe('5 copos de √°gua');
    expect(hydrate('1 copo de catuaba, 1 cervejas e 1 copo de vinho')).toBe('3 copos de √°gua');
    expect(hydrate('4 caipirinhas e 2 cervejas')).toBe('6 copos de √°gua');
  });
});
B√¥nus
üöÄ 1 - Voc√™ est√° pronto para um desafio?! Neste exerc√≠cio, voc√™ ir√° praticar o desenvolvimento orientado a testes implementando:
A fun√ß√£o;
Os testes para essa fun√ß√£o;
Considere os dados abaixo. Voc√™ deve criar uma fun√ß√£o que receba dois par√¢metros: o id do funcion√°rio e a informa√ß√£o dispon√≠vel sobre ele (firstName, lastName, specialities). Voc√™ tamb√©m dever√° criar os testes para essa fun√ß√£o. Sua fun√ß√£o dever√° ent√£o retornar os resultados da busca pelo id para aquele funcion√°rio e a informa√ß√£o consultada. Caso o id n√£o conste no quadro de funcion√°rios, sua fun√ß√£o deve retornar o erro "ID n√£o identificada". Se a informa√ß√£o que se quer acessar n√£o existir, a fun√ß√£o deve retornar o erro "Informa√ß√£o indispon√≠vel".
Copiar
// Dados
const professionalBoard = [
  {
    id: '8579-6',
    firstName: 'Ana',
    lastName: 'Gates',
    specialities: ['UX', 'Design'],
  },
  {
    id: '5569-4',
    firstName: 'George',
    lastName: 'Jobs',
    specialities: ['Frontend', 'Redux', 'React', 'CSS'],
  },
  {
    id: '4456-4',
    firstName: 'Leila',
    lastName: 'Zuckerberg',
    specialities: ['Context API', 'RTL', 'Bootstrap'],
  },
  {
    id: '1256-4',
    firstName: 'Linda',
    lastName: 'Bezos',
    specialities: ['Hooks', 'Context API', 'Tailwind CSS'],
  },
  {
    id: '9852-2-2',
    firstName: 'Jeff',
    lastName: 'Cook',
    specialities: ['Ruby', 'SQL'],
  },
  {
    id: '4678-2',
    firstName: 'Paul',
    lastName: 'Dodds',
    specialities: ['Backend'],
  },
];

// Pesquisa
const searchEmployee = (id, detail) => {
  // Implemente seu c√≥digo aqui
};
Como ponto de partida, comece implementando um teste para checar se a fun√ß√£o existe. Execute o teste que voc√™ escreveu e implemente, na fun√ß√£o, a funcionalidade que passar√° nesse teste. Repita esse processo at√© que todos os retornos esperados sejam testados.




